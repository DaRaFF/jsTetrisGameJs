/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./img/blocks.png":
/*!************************!*\
  !*** ./img/blocks.png ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"f513dd064f4d16c0599f2ae270d6834c.png\");\n\n//# sourceURL=webpack:///./img/blocks.png?");

/***/ }),

/***/ "./img/icon.png":
/*!**********************!*\
  !*** ./img/icon.png ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"8eadde9711026ee50a6bc9b15844d9e2.png\");\n\n//# sourceURL=webpack:///./img/icon.png?");

/***/ }),

/***/ "./js/Tetris/Block.js":
/*!****************************!*\
  !*** ./js/Tetris/Block.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar screen = __webpack_require__(/*! ./screen */ \"./js/Tetris/screen.js\").screen;\n\n/**\n * Block\n *\n * @param {Array} shape The shape of the block in tiles\n * \n * Example:\n * [ \n *   [0,1,0],\n *   [0,1,0],\n *   [1,1,0],    \n * ]\n * @param {Number} tileX\n * @param {Number} tileY\n * @returns\n */\nvar Block = function(shape, tileX, tileY){\n    var that = this;\n    /** The x position of the block on the map in tiles\n    * @type Number\n    */\n    this.tileX = tileX;\n    /** The y position of the block on the map in tiles\n    * @type Number\n    */\n    this.tileY = tileY;\n    /** \n    * The shape of the block in tiles\n    * \n    * Example:\n    * [ \n    *   [0,1,0],\n    *   [0,1,0],\n    *   [1,1,0],    \n    * ]\n    * @type Array\n    */\n    this.shape = shape;\n    this.shapeSurface;\n    this.tetraederSurface;\n    this.isUpdated = true;\n    \n    this.update = function(){\n        \n    }\n    \n    /**\n   * Block rendering\n   *\n   * @return {void} \n   */\n    this.draw = function(display){\n        if(this.isUpdated){\n            this.tetraederSurface = new gamejs.graphics.Surface([screen.canvas.width, screen.canvas.height]);\n            for(var y = 0; y < that.shape.length; y++){\n                for(var x = 0; x < that.shape[0].length; x++){\n                    if(that.shape[y][x]){\n                        var rect = new gamejs.Rect(\n                            screen.tilesX * x + screen.tilesX * that.tileX, \n                            screen.tilesY * y + screen.tilesY * that.tileY, \n                            screen.tilesX, \n                            screen.tilesY\n                            );\n                        this.tetraederSurface.blit(this.shapeSurface, rect);\n                    }\n                }\n            }\n        }\n        display.blit(this.tetraederSurface);\n        this.isUpdated = false;\n    }\n    \n    /**\n    * Turns the shape in given direction\n    *\n    * @param {String} direction 'right'|'left'\n    * @return {void}\n    */\n    this.turn = function(direction){\n        this.isUpdated = true;\n        var oldShape = this.shape;\n        var newShape = [];\n        switch (oldShape.length) {\n            case 2:\n                newShape = [[],[]];\n                break;\n            case 3:\n                newShape = [[],[],[]];\n                break;\n            case 4:\n                newShape = [[],[],[],[]];\n                break;\n            default:\n                break;\n        }\n\n        var newTilePosX;\n        var newTilePosY;\n    \n        for(var y = 0; y < oldShape.length; y++){\n            for(var x = 0; x < oldShape[0].length; x++){\n                if(direction === 'right'){\n                    newTilePosX = oldShape.length - 1 - y;\n                    newTilePosY = x;\n                    newShape[newTilePosY][newTilePosX] = oldShape[y][x];\n                }\n                if(direction === 'left'){\n                    newTilePosX = y;\n                    newTilePosY = oldShape[0].length - 1 - x;\n                    newShape[newTilePosY][newTilePosX] = oldShape[y][x];\n                }\n            }\n        }\n        this.shape = newShape;\n    }\n    \n    /**\n   * Collision detection between block and the map if the block is moving in x,y axis\n   *\n   * @param {Map} map\n   * @param {integer} dTilesX check collision if block is moved dTilesX in x-Axis\n   * @param {integer} dTilesY check collision if block is moved dTilesX in y-Axis\n   * @returns boolean\n   */\n    this.collide = function(map, dTilesX, dTilesY){\n        for(var y = 0; y < that.shape.length; y++){\n            for(var x = 0; x < that.shape[0].length; x++){\n                if(that.shape[y][x]){\n                    var newTilePosX = that.tileX + x + dTilesX;\n                    var newTilePosY = that.tileY + y + dTilesY;\n                    //collision border\n                    if( newTilePosX >= map.shape[0].length || //collision right border\n                        newTilePosX  < 0 || //collision left border\n                        newTilePosY >= map.shape.length ){ //collision bottom border\n                        return true;\n                    }\n                    //collision check horizontal with map\n                    if(map.shape[newTilePosY][newTilePosX]){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\nexports.Block = Block;\n\n\n//# sourceURL=webpack:///./js/Tetris/Block.js?");

/***/ }),

/***/ "./js/Tetris/BlockElements.js":
/*!************************************!*\
  !*** ./js/Tetris/BlockElements.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\n\nvar BlockElements = [\n    {\n        name: 'J',\n        shape: [\n            [0,1,0],\n            [0,1,0],\n            [1,1,0],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 0,\n        imageY: 0\n    },\n    {\n        name: 'L',\n        shape: [\n            [0,1,0],\n            [0,1,0],\n            [0,1,1],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 50,\n        imageY: 0\n    },\n    {\n        name: 'T',\n        shape: [\n            [0,0,0],\n            [1,1,1],\n            [0,1,0],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 100,\n        imageY: 0\n    },\n    {\n        name: 'S',\n        shape: [\n            [0,1,0],\n            [0,1,1],\n            [0,0,1],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 150,\n        imageY: 0\n    },\n    {\n        name: 'O',\n        shape: [\n        [1,1],\n        [1,1],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 200,\n        imageY: 0\n    },\n    {\n        name: 'Z',\n        shape: [\n        [0,0,1],\n        [0,1,1],\n        [0,1,0],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 0,\n        imageY: 50\n    },\n    {\n        name: 'I',\n        shape: [\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        ],\n        imageSrc: gamejs.image.load('./img/blocks.png'),\n        imageX: 50,\n        imageY: 50\n    },\n];\n\n\n\nexports.BlockElements = BlockElements;\n\n\n//# sourceURL=webpack:///./js/Tetris/BlockElements.js?");

/***/ }),

/***/ "./js/Tetris/BlockFactory.js":
/*!***********************************!*\
  !*** ./js/Tetris/BlockFactory.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar Block = __webpack_require__(/*! ./Block */ \"./js/Tetris/Block.js\").Block;\n\n/**\n* Factory for Block creation\n*\n* @return\n*/\nvar BlockFactory = function (){\n    \n    /**\n    * Factory for Block creation\n    * blockElements are default defined in BlockElements\n    * \n    * @param {BlockElements} blockElements where the Factory can chose for creation\n    * @param {Number} tileX The x start position of Block in Map\n    * @param {Number} tileX The y start position of Block in Map\n    * @return {Block} Block\n    */\n    this.create = function(blockElements, tileX, tileY){\n        var blockElement = blockElements[Math.floor(Math.random() * blockElements.length)];\n        var block = new Block(blockElement.shape, tileX, tileY);\n        block.shapeSurface = new gamejs.graphics.Surface([50, 50]);\n        \n        block.shapeSurface.blit(\n            blockElement.imageSrc,\n            (new gamejs.Rect(\n                [0,0], \n                [50,50]\n                )\n            ),\n            (new gamejs.Rect(\n                [blockElement.imageX,blockElement.imageY], \n                [50,50]\n                ))\n            );\n        return block;\n    }\n}\n\nexports.BlockFactory = BlockFactory;\n\n\n\n\n//# sourceURL=webpack:///./js/Tetris/BlockFactory.js?");

/***/ }),

/***/ "./js/Tetris/Map.js":
/*!**************************!*\
  !*** ./js/Tetris/Map.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar screen = __webpack_require__(/*! ./screen */ \"./js/Tetris/screen.js\").screen;\n\n/**\n * Map\n *\n * @param {Number} tilesX number of tiles in x direction \n * @param {Number} tilesY number of tiles in y direction\n * @returns\n */\nvar Map = function(tilesX, tilesY){\n    this.tilesX = tilesX;\n    this.tilesY = tilesY;\n    this.shape = [[]];\n    this.shapeSurface = [[]];\n    this.mapSurface;\n    this.isUpdated = true;\n    \n    this.init = function(){\n        for (var y = 0; y < this.tilesY ; y++) {\n            this.shape[y] = [];\n            this.shapeSurface[y] = [];\n            for (var x = 0; x < this.tilesX; x++) {\n                this.shape[y][x] = 0;\n                this.shapeSurface[y][x] = undefined;\n            }\n    \n        }\n    }\n    \n    this.draw = function(display){\n        if(this.isUpdated){\n            this.mapSurface = new gamejs.graphics.Surface([screen.screen_width, screen.screen_height]);\n            for(var y = 0; y < this.shape.length; y++){\n                for(var x = 0; x < this.shape[0].length; x++){\n                    if(this.shape[y][x]){\n                        var rect = new gamejs.Rect(\n                            screen.tilesX * x, \n                            screen.tilesX * y, \n                            screen.tilesX, \n                            screen.tilesY\n                            );\n                        this.mapSurface.blit(this.shapeSurface[y][x], rect);\n                    }\n                }\n            }\n        }\n        display.blit(this.mapSurface);\n        this.isUpdated = false;\n    }\n\n    this.update = function(){\n    \n    } \n    \n    /**\n   * Fixes a block in the map\n   *\n   * @param {Block} block\n   */\n    this.fixStone = function(block){\n        this.isUpdated = true;\n        for(var y = 0; y < block.shape.length; y++){\n            for(var x = 0; x < block.shape[0].length; x++){\n                if(block.shape[y][x]){\n                    var newTilePosX = block.tileX + x;\n                    var newTilePosY = block.tileY + y;\n                    this.shape[newTilePosY][newTilePosX] = 1;\n                    this.shapeSurface[newTilePosY][newTilePosX] = block.shapeSurface;\n                }\n            }\n        }\n    }\n    \n    /**\n   * Check if row is full\n   *\n   * @param {integer} tileYPos row in map to check (0 - tileCountY)\n   * @return {boolean}\n   */\n    this.rowFull = function(tileYPos){\n        for(var x = 0; x < this.shape[0].length; x++){\n            if(!this.shape[tileYPos][x]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n   * Delete row\n   *\n   * @param {integer} row in map (0 - tileCountY)\n   * @return {void}\n   */\n    this.rowDelete = function(tileYPos){\n        this.isUpdated = true;\n        this.shape.splice(tileYPos,1);\n        this.shapeSurface.splice(tileYPos,1);\n    }\n\n    /**\n   * Delete all full rows in map\n   *\n   * @return {void}\n   */\n    this.reduceLines = function(){\n        for(var y = 0; y < this.shape.length; y++){\n            if(this.rowFull(y)){\n                this.rowDelete(y);\n                this.shape.unshift([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n                this.shapeSurface.unshift([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n            }\n        }\n    }\n    \n    /**\n   * Check if map is full\n   *\n   * @return {boolean}\n   */\n    this.mapFull = function(){\n        var y = 1;\n        for(var x = 0; x < this.shape[0].length; x++){\n            if(this.shape[y][x]){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nexports.Map = Map;\n\n\n\n\n//# sourceURL=webpack:///./js/Tetris/Map.js?");

/***/ }),

/***/ "./js/Tetris/Player.js":
/*!*****************************!*\
  !*** ./js/Tetris/Player.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\n\n/**\n * Player\n * \n * @param {Tetris} game The game\n * @param {Map} map\n *\n * @returns\n */\nvar Player = function(game, map){\n    this.game = game;\n    this.map = map;\n    this.currentBlock;\n    this.nextBlock;\n    this.level = 0;\n    this.lines = 0;\n    this.score = 0;\n    this.input = null;\n    this.isGameOver = false;\n    \n    this.init = function(){\n        this.currentBlock = this.game.createBlock();\n        this.nextBlock = this.game.createBlock();\n    }\n    \n    this.update = function(){\n        switch(this.input){\n            case \"RIGHT\":\n                if(!this.currentBlock.collide(this.map, 1, 0)){\n                    this.currentBlock.tileX++;\n                    this.currentBlock.isUpdated = true;\n                }\n                break;\n            case \"LEFT\":\n                if(!this.currentBlock.collide(this.map, -1, 0)){\n                    this.currentBlock.tileX--;\n                    this.currentBlock.isUpdated = true;\n                }\n                break;\n            case \"DOWN\":\n                if(this.currentBlock.collide(this.map, 0, 1)){\n                    this.map.fixStone(this.currentBlock, this.map);\n                    this.map.reduceLines();\n                    this.currentBlock = this.nextBlock;\n                    this.nextBlock = this.game.createBlock();\n                }\n                this.currentBlock.tileY++;\n                this.currentBlock.isUpdated = true;\n                break;\n            case \"TURN\":\n                this.currentBlock.turn('right');\n                if(this.currentBlock.collide(this.map, 0, 0)){\n                    this.currentBlock.turn('left');\n                }\n                break;\n            default:\n                break;\n        }\n        this.input = null;\n    }\n    \n    this.draw = function(display){\n        this.currentBlock.draw(display); \n    }\n}\n\nexports.Player = Player;\n\n\n\n\n//# sourceURL=webpack:///./js/Tetris/Player.js?");

/***/ }),

/***/ "./js/Tetris/Scene/Director.js":
/*!*************************************!*\
  !*** ./js/Tetris/Scene/Director.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\")\nconst screen = __webpack_require__(/*! ../screen */ \"./js/Tetris/screen.js\").screen\nconst touch = __webpack_require__(/*! ../../Util/touch */ \"./js/Util/touch.js\")\nconst orientation = __webpack_require__(/*! ../../Util/orientation */ \"./js/Util/orientation.js\")\nconst controller = __webpack_require__(/*! ../../Util/controller */ \"./js/Util/controller.js\")\n\nconst Director = function () {\n  touch.init()\n  orientation.init()\n  controller.init()\n  let onAir = false\n  let activeScene = null\n\n  this.start = function (scene) {\n    onAir = true\n    this.replaceScene(scene)\n    return\n  }\n\n  this.replaceScene = function (scene) {\n    activeScene = scene\n  }\n\n  this.getScene = function () {\n    return activeScene\n  }\n\n  screen.update()\n  const display = gamejs.display.setMode([screen.screen_width, screen.screen_height])\n\n  gamejs.onTick(function(msDuration) {\n    if (!onAir) return\n\n    if (activeScene.handleEvent) gamejs.event.onEvent(activeScene.handleEvent)\n    if (activeScene.update) {\n      activeScene.update(msDuration)\n    }\n    if (activeScene.draw) {\n      activeScene.draw(display)\n    }\n  })\n\n  gamejs.event.onEvent(function(event) {\n    activeScene.handleEvent(event)\n  })\n\n  return this\n}\n\nexports.Director = Director\n\n\n//# sourceURL=webpack:///./js/Tetris/Scene/Director.js?");

/***/ }),

/***/ "./js/Tetris/Scene/EndScene.js":
/*!*************************************!*\
  !*** ./js/Tetris/Scene/EndScene.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar GameScene = __webpack_require__(/*! ./GameScene */ \"./js/Tetris/Scene/GameScene.js\").GameScene;\nvar StartScene = __webpack_require__(/*! ./StartScene */ \"./js/Tetris/Scene/StartScene.js\").StartScene;\nvar screen = __webpack_require__(/*! ../screen */ \"./js/Tetris/screen.js\").screen;\n\nvar EndScene = function(director) {\n\n    this.handleEvent = function(event) {\n        if (event.key === gamejs.event.K_y) {\n            var GameScene = __webpack_require__(/*! ./GameScene */ \"./js/Tetris/Scene/GameScene.js\").GameScene;\n            director.replaceScene(new GameScene(director));\n        }\n        if (event.key === gamejs.event.K_n) {\n            var StartScene = __webpack_require__(/*! ./StartScene */ \"./js/Tetris/Scene/StartScene.js\").StartScene;\n            director.replaceScene(new StartScene(director));\n        }\n    };\n\n    this.draw = function(display) {\n        display.clear();\n        \n        var title = new gamejs.font.Font('40px monospace');\n        var tetrisSurface = title.render('Game Over');\n        display.blit(tetrisSurface, [70,100]);\n        \n        var again = new gamejs.font.Font('20px monospace');\n        var againSurface = again.render('Try again? (Y/N)');\n        display.blit(againSurface, [70,140]);\n    };\n\n    return this;\n};\n\nexports.EndScene = EndScene;\n\n//# sourceURL=webpack:///./js/Tetris/Scene/EndScene.js?");

/***/ }),

/***/ "./js/Tetris/Scene/GameScene.js":
/*!**************************************!*\
  !*** ./js/Tetris/Scene/GameScene.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\")\nconst screen = __webpack_require__(/*! ../screen */ \"./js/Tetris/screen.js\").screen\nconst Tetris = __webpack_require__(/*! ../Tetris */ \"./js/Tetris/Tetris.js\").Tetris\nconst fps = __webpack_require__(/*! ../../Util/fps */ \"./js/Util/fps.js\")\nconst EndScene = __webpack_require__(/*! ./EndScene */ \"./js/Tetris/Scene/EndScene.js\").EndScene\n\nconst GameScene = function (director) {\n  const fpsDisplay = new fps.FpsDisplay()\n  // handle input\n  this.handleEvent = function (event) {\n    // keyboard input\n    if (event.type === gamejs.event.KEY_DOWN) {\n      if (event.key === gamejs.event.K_UP) {\n        Tetris.game.player.input = 'TURN'\n      }\n      if (event.key === gamejs.event.K_DOWN) {\n        Tetris.game.player.input = 'DOWN'\n      }\n      if (event.key === gamejs.event.K_RIGHT) {\n        Tetris.game.player.input = 'RIGHT'\n      }\n      if (event.key === gamejs.event.K_LEFT) {\n        Tetris.game.player.input = 'LEFT'\n      }\n    }\n    // mouse input\n    if (event.type === gamejs.event.MOUSE_DOWN) {\n      if( screen.getInnerHeight() * 2 / 3 <= event.pos[1]) {\n        Tetris.game.player.input = 'DOWN'\n        return\n      }\n      if (screen.getInnerWidth() * 1 / 3 >= event.pos[0]) {\n        Tetris.game.player.input = 'LEFT'\n        return\n      }\n      if (screen.getInnerWidth() * 1 / 3 <= event.pos[0] && screen.getInnerWidth() * 2 / 3 >= event.pos[0]) {\n        Tetris.game.player.input = 'TURN'\n        return\n      }\n      Tetris.game.player.input = 'RIGHT'\n    }\n  }\n\n  this.update = function (msDuration) {\n    screen.update()\n    Tetris.game.update()\n    fpsDisplay.update(msDuration)\n    if (Tetris.game.gameOver) {\n      director.replaceScene(new EndScene(director))\n    }\n  }\n\n  this.draw = function (display) {\n    display.clear()\n    Tetris.game.draw(display)\n    fpsDisplay.draw(display)\n  }\n\n  Tetris.game = new Tetris()\n  return this\n}\n\nexports.GameScene = GameScene\n\n\n//# sourceURL=webpack:///./js/Tetris/Scene/GameScene.js?");

/***/ }),

/***/ "./js/Tetris/Scene/StartScene.js":
/*!***************************************!*\
  !*** ./js/Tetris/Scene/StartScene.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar GameScene = __webpack_require__(/*! ./GameScene */ \"./js/Tetris/Scene/GameScene.js\").GameScene;\nvar screen = __webpack_require__(/*! ../screen */ \"./js/Tetris/screen.js\").screen;\n\nvar StartScene = function(director) {\n\n    this.handleEvent = function(event) {\n        if (event.type === gamejs.event.MOUSE_UP) {\n            director.replaceScene(new GameScene(director));\n        }\n    };\n\n    this.draw = function(display) {\n        display.clear();\n        display.blit(startPicture);\n\n        var font = new gamejs.font.Font('40px monospace');\n        var surface = font.render('Tetris');\n        display.blit(surface, [70,100]);\n\n        font = new gamejs.font.Font('15px monospace');\n        surface = font.render('created by @ralphmeier');\n        display.blit(surface, [40,160]);\n    };\n\n    var startPicture = gamejs.image.load('./img/icon.png');\n    return this;\n};\n\nexports.StartScene = StartScene;\n\n//# sourceURL=webpack:///./js/Tetris/Scene/StartScene.js?");

/***/ }),

/***/ "./js/Tetris/Tetris.js":
/*!*****************************!*\
  !*** ./js/Tetris/Tetris.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar Map = __webpack_require__(/*! ./Map */ \"./js/Tetris/Map.js\").Map;\nvar Player = __webpack_require__(/*! ./Player */ \"./js/Tetris/Player.js\").Player;\nvar BlockFactory = __webpack_require__(/*! ./BlockFactory */ \"./js/Tetris/BlockFactory.js\").BlockFactory;\nvar BlockElements = __webpack_require__(/*! ./BlockElements */ \"./js/Tetris/BlockElements.js\").BlockElements;\nvar Timer = __webpack_require__(/*! ./Timer */ \"./js/Tetris/Timer.js\").Timer;\n\nvar Tetris = {\n    game: null\n};\n\n/**\n * Tetris Main\n *\n * @returns\n */\nvar Tetris = function(){\n    this.map;\n    this.player;\n    this.timer;\n    this.sound;\n    this.gameOver = false;\n    \n    this.tileXStartPosition = 7;\n    this.tileYStartPosition = 0;\n    \n    this.init = function(){\n//        this.sound = new Sound();\n//        this.sound.init();\n        this.map = new Map(16, 16);\n        this.map.init();\n        this.player = new Player(this, this.map);\n        this.player.init();\n        this.timer = new Timer(this, 5000, function(game){\n            game.player.input = \"DOWN\";\n        });\n    }\n    \n    this.update= function(){\n        this.timer.update();\n        this.player.update();\n        this.updateGameState();\n    }\n    \n    this.draw = function(display){\n        this.map.draw(display);\n        this.player.draw(display);\n    }\n\n    /**\n   * Create a new block\n   *\n   * @returns {Block}\n   */\n    this.createBlock = function(){\n        var blockFactory = new BlockFactory();\n        return blockFactory.create(BlockElements, this.tileXStartPosition, this.tileYStartPosition);\n    }\n    \n    this.updateGameState = function(){\n        if(this.map.mapFull()){\n            this.gameOver = true;\n        }\n    }\n    \n    \n    \n    this.init();\n}\n\nexports.Tetris = Tetris;\n\n\n\n\n\n//# sourceURL=webpack:///./js/Tetris/Tetris.js?");

/***/ }),

/***/ "./js/Tetris/Timer.js":
/*!****************************!*\
  !*** ./js/Tetris/Timer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Timer = function(game, fallDownTime, callback){\n    this.game = game;\n    this.lastTick = new Date;\n    this.fallDownTime = fallDownTime;\n    this.fallDownTimeLeft = fallDownTime;\n\n    this.update = function(){\n        this.fallDownTimeLeft -= new Date - this.lastTick;\n        this.lastTick = new Date;\n        if(this.fallDownTimeLeft <= 0){\n            this.fallDownTimeLeft = this.fallDownTime;\n            callback(this.game);\n        }\n    }\n}\n\nexports.Timer = Timer;\n\n//# sourceURL=webpack:///./js/Tetris/Timer.js?");

/***/ }),

/***/ "./js/Tetris/screen.js":
/*!*****************************!*\
  !*** ./js/Tetris/screen.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var screen = {\n    tileCountX: 16,\n    tileCountY: 16,\n    canvas: null,\n    tilesX: 0,\n    tilesY: 0\n};\n\nscreen.getWidth = function(realWidth, realHeight){\n    var smaller  = Math.min(realWidth,realHeight);\n    return (smaller > 600 ? 600 : smaller);\n};\nscreen.getInnerHeight = function(){\n    return window.innerHeight;\n};\nscreen.getInnerWidth = function(){\n    return window.innerWidth;\n};\n\nscreen.update = function(){\n    screen.canvas = document.getElementById('gjs-canvas');\n    screen.tilesX = screen.canvas.width / screen.tileCountX;\n    screen.tilesY = screen.canvas.height / screen.tileCountY;\n    screen.screen_width = screen.getWidth(screen.getInnerWidth(), screen.getInnerHeight());\n    screen.screen_height = screen.screen_width;\n}\n\nexports.screen = screen;\n\n\n\n\n//# sourceURL=webpack:///./js/Tetris/screen.js?");

/***/ }),

/***/ "./js/Util/controller.js":
/*!*******************************!*\
  !*** ./js/Util/controller.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\")\n\nfunction connecthandler (e) {\n  addgamepad(e.gamepad)\n}\n\nfunction addgamepad (gamepad) {\n  console.log('gamepad connected')\n}\n\nfunction triggerEvent (type, keycode) {\n  const evt = new Event(type, {'bubbles': true, 'cancelable': false})\n  evt.keyCode = keycode\n  document.dispatchEvent(evt)\n}\n\nfunction controllerHandler (event) {\n  const controller = navigator.getGamepads()[0]\n\n  if (!controller) return\n\n  // cross down\n  if (controller.buttons[13].pressed) {\n    triggerEvent('keydown', gamejs.event.K_DOWN)\n  }\n  // B\n  if (controller.buttons[1].pressed) {\n    triggerEvent('keydown', gamejs.event.K_UP)\n  }\n  // cross up\n  if (controller.buttons[12].pressed) {\n    triggerEvent('keydown', gamejs.event.K_UP)\n  }\n  // cross left\n  if (controller.buttons[14].pressed) {\n    triggerEvent('keydown', gamejs.event.K_LEFT)\n  }\n  // cross right\n  if (controller.buttons[15].pressed) {\n    triggerEvent('keydown', gamejs.event.K_RIGHT)\n  }\n}\n\nfunction disconnectHandler (event) {\n  console.log('disconnected gamepad')\n}\n\nexports.init = function () {\n  // this is the most simple gameloop, but it needs to be improved\n  setInterval(controllerHandler, 70)\n\n  const haveEvents = window.GamepadEvent\n  if (haveEvents) {\n    window.addEventListener('gamepadconnected', connecthandler)\n    window.addEventListener('gamepaddisconnected', disconnectHandler)\n  }\n\n  const haveWebkitEvents = window.WebKitGamepadEvent\n  if (haveWebkitEvents) {\n    window.addEventListener('webkitgamepadconnected', connecthandler)\n    window.addEventListener('webkitgamepaddisconnected', disconnectHandler)\n  }\n\n  return\n}\n\n\n//# sourceURL=webpack:///./js/Util/controller.js?");

/***/ }),

/***/ "./js/Util/fps.js":
/*!************************!*\
  !*** ./js/Util/fps.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar screen = __webpack_require__(/*! ../Tetris/screen */ \"./js/Tetris/screen.js\");\n\nexports.FpsDisplay = function() {\n    // fps counter\n    var lastDurations = [];\n    var fpsFont = new gamejs.font.Font();\n    var fpsAvg = 60;\n\n    this.update = function(msDuration) {\n        // fps\n        lastDurations.push(msDuration);\n        var sum = 0;\n        lastDurations = lastDurations.splice(lastDurations.length-200, 200);\n        lastDurations.forEach(function(ld) {\n            sum += ld;\n        });\n        fpsAvg = Math.ceil(1000 / (sum / lastDurations.length));\n    };\n\n    this.draw = function(display) {\n        display.blit(fpsFont.render('' + fpsAvg, '#ff33ff'), [screen.SCREEN_WIDTH - 100, 5]);\n        return;\n    };\n\n    return this;\n};\n\n//# sourceURL=webpack:///./js/Util/fps.js?");

/***/ }),

/***/ "./js/Util/orientation.js":
/*!********************************!*\
  !*** ./js/Util/orientation.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview handle mobile events for screen orientation\n * @see http://www.sitepoint.com/iphone-development-12-tips-2/\n */\n\nconst gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\")\nconst screen = __webpack_require__(/*! ../Tetris/screen */ \"./js/Tetris/screen.js\").screen\n\nfunction orientationHandler (event) {\n  screen.update()\n  gamejs.display.setMode([screen.screen_width, screen.screen_height])\n  return\n}\n\nexports.init = function () {\n  document.addEventListener('orientationchange', orientationHandler, true)\n  return\n}\n\n\n//# sourceURL=webpack:///./js/Util/orientation.js?");

/***/ }),

/***/ "./js/Util/touch.js":
/*!**************************!*\
  !*** ./js/Util/touch.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview map touch events to mouse events for drag & drop\n * @see https://github.com/oberhamsi/planetary-gamejs/blob/master/touch.js\n * @see http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/\n */\n\nconst EVENT_MAPPING = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup'\n}\n\nfunction touchHandler (event) {\n  const touches = event.changedTouches\n  const first = touches[0]\n  const type = EVENT_MAPPING[event.type]\n\n  const simulatedEvent = document.createEvent('MouseEvent')\n  simulatedEvent.initMouseEvent(type, true, true, window, 1,\n    first.screenX, first.screenY,\n    first.clientX, first.clientY, false,\n    false, false, false, 0 /* left */, null)\n\n  first.target.dispatchEvent(simulatedEvent)\n  if (event.type === 'touchmove') {\n    event.preventDefault()\n    window.scroll(0, 0)\n    return\n  }\n  return\n}\n\nexports.init = function () {\n  document.body.style['-webkit-touch-callout'] = 'none'\n  document.addEventListener('touchstart', touchHandler, true)\n  document.addEventListener('touchmove', touchHandler, true)\n  document.addEventListener('touchend', touchHandler, true)\n  document.addEventListener('touchcancel', touchHandler, true)\n  return\n}\n\n\n//# sourceURL=webpack:///./js/Util/touch.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! gamejs */ \"./node_modules/gamejs/src/gamejs.js\")\nconst screen = __webpack_require__(/*! ./Tetris/screen */ \"./js/Tetris/screen.js\").screen\n\n// load images\n__webpack_require__(/*! ../img/blocks.png */ \"./img/blocks.png\")\n__webpack_require__(/*! ../img/icon.png */ \"./img/icon.png\")\n\nfunction main () {\n  const Director = __webpack_require__(/*! ./Tetris/Scene/Director */ \"./js/Tetris/Scene/Director.js\").Director\n  const StartScene = __webpack_require__(/*! ./Tetris/Scene/StartScene */ \"./js/Tetris/Scene/StartScene.js\").StartScene\n  const director = new Director()\n  const startScene = new StartScene(director)\n  director.start(startScene)\n}\n\ngamejs.preload([\n  './img/icon.png',\n  './img/blocks.png'\n])\ngamejs.ready(main)\n\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs.js":
/*!*******************************************!*\
  !*** ./node_modules/gamejs/src/gamejs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var matrix = __webpack_require__(/*! ./gamejs/math/matrix */ \"./node_modules/gamejs/src/gamejs/math/matrix.js\");\nvar objects = __webpack_require__(/*! ./gamejs/utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\");\nvar Callback = __webpack_require__(/*! ./gamejs/utils/callback */ \"./node_modules/gamejs/src/gamejs/utils/callback.js\").Callback;\n\n/**\n * @fileoverview  `gamejs.ready()` is maybe the most important function as it kickstarts your app:\n *\n *     var gamejs = require('gamejs');\n *     ready(function() {\n *         gamejs.logging.info('I am ready!')\n *     });\n *\n * If you use images or sounds preload all assets with `gamejs.preload(['./files/foo.png'])` before calling `ready()`.\n *\n * Also in this module is the `Rect` class which is generally useful when dealing with Surfaces and simple rectangles (e.g. for collisions).\n */\n// preloading stuff\nvar gamejs = exports;\nvar RESOURCES = {};\n/**\n * @ignore\n */\nexports.thread = __webpack_require__(/*! ./gamejs/thread */ \"./node_modules/gamejs/src/gamejs/thread.js\");\n\n\n/**\n * ReadyFn is called once all modules and assets are loaded.\n * @param {Function} callbackFunction the function to be called once gamejs finished loading\n * @name ready\n */\nif (gamejs.thread.inWorker === true) {\n   exports.ready = function(readyFn) {\n      __webpack_require__(/*! ./gamejs/thread */ \"./node_modules/gamejs/src/gamejs/thread.js\")._ready();\n      gamejs.init();\n      readyFn();\n   };\n} else {\n   exports.ready = function(readyFn) {\n\n      var getMixerProgress = null;\n      var getImageProgress = null;\n\n      // init time instantly - we need it for preloaders\n      gamejs.time.init();\n\n      // 2.\n      function _ready() {\n         if (!document.body) {\n            return window.setTimeout(_ready, 50);\n         }\n         getImageProgress = gamejs.image.preload(RESOURCES);\n         try {\n            getMixerProgress = gamejs.audio.preload(RESOURCES);\n         } catch (e) {\n            gamejs.debug('Error loading audio files ', e);\n         }\n         window.setTimeout(_readyResources, 50);\n      }\n\n      // 3.\n      function _readyResources() {\n         if (getImageProgress() < 1 || getMixerProgress() < 1) {\n            return window.setTimeout(_readyResources, 100);\n         }\n         gamejs.display.init();\n         gamejs.image.init();\n         gamejs.audio.init();\n         gamejs.event.init();\n         gamejs.math.random.init();\n         readyFn();\n      }\n\n      // 1.\n      window.setTimeout(_ready, 13);\n\n      function getLoadProgress() {\n         if (getImageProgress) {\n            return (0.5 * getImageProgress()) + (0.5 * getMixerProgress());\n         }\n         return 0.1;\n      }\n\n      return getLoadProgress;\n   };\n}\n\n/**\n * Initialize all gamejs modules. This is automatically called\n * by `gamejs.ready()`.\n * @returns {Object} the properties of this objecte are the moduleIds that failed, they value are the exceptions\n * @ignore\n */\nexports.init = function() {\n   var errorModules = {};\n   ['time', 'display', 'image', 'audio', 'event'].forEach(function(moduleName) {\n      try {\n         gamejs[moduleName].init();\n      } catch (e) {\n         errorModules[moduleName] = e.toString();\n      }\n   });\n   return errorModules;\n};\n\nvar resourceBaseHref = function() {\n    return (window.$g && window.$g.resourceBaseHref) || document.location.href;\n};\n\n/**\n * Preload resources.\n * @param {Array} resources list of resources paths\n * @name preload\n */\nvar preload = exports.preload = function(resources) {\n   var uri = __webpack_require__(/*! ./gamejs/utils/uri */ \"./node_modules/gamejs/src/gamejs/utils/uri.js\");\n   var baseHref = resourceBaseHref();\n   resources.forEach(function(res) {\n      RESOURCES[res] = uri.resolve(baseHref, res);\n   }, this);\n   return;\n};\n\n/**\n * The function passed to `onTick` will continously be called at a\n * frequency determined by the browser (typically between 1 and 60 times per second).\n * @param {Function} callbackFunction the function you want to be called\n * @param {Function} callbackScope optional scope for the function call\n */\nexports.onTick = function(fn, scope) {\n  /** ignore **/\n  exports.time._CALLBACKS.push(new Callback(fn, scope));\n};\n\n/**\n * Normalize various ways to specify a Rect into {left, top, width, height} form.\n * @ignore\n *\n */\nvar normalizeRectArguments = exports.normalizeRectArguments = function () {\n   var left = 0;\n   var top = 0;\n   var width = 0;\n   var height = 0;\n\n   if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {\n         left = arguments[0][0];\n         top = arguments[0][1];\n         width = arguments[1][0];\n         height = arguments[1][1];\n      } else {\n         left = arguments[0];\n         top = arguments[1];\n      }\n   } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n      left = arguments[0][0];\n      top = arguments[0][1];\n      width = arguments[0][2];\n      height = arguments[0][3];\n   } else if (arguments.length === 1 && arguments[0] instanceof Rect) {\n      left = arguments[0].left;\n      top = arguments[0].top;\n      width = arguments[0].width;\n      height = arguments[0].height;\n   } else if (arguments.length === 4) {\n      left = arguments[0];\n      top = arguments[1];\n      width = arguments[2];\n      height = arguments[3];\n   } else {\n      throw new Error('not a valid rectangle specification');\n   }\n   return {left: left || 0, top: top || 0, width: width || 0, height: height || 0};\n};\n\n\n/**\n * Creates a Rect. Rects are used to hold rectangular areas. There are a couple\n * of convinient ways to create Rects with different arguments and defaults.\n *\n * Any function that requires a `gamejs.Rect` argument also accepts any of the\n * constructor value combinations `Rect` accepts.\n *\n * Rects are used a lot. They are good for collision detection, specifying\n * an area on the screen (for blitting) or just to hold an objects position.\n *\n * The Rect object has several virtual attributes which can be used to move and align the Rect:\n *\n *   top, left, bottom, right\n *   topleft, bottomleft, topright, bottomright\n *   center\n *   width, height\n *   w,h\n *\n * All of these attributes can be assigned to.\n * Assigning to width or height changes the dimensions of the rectangle; all other\n * assignments move the rectangle without resizing it. Notice that some attributes\n * are Numbers and others are pairs of Numbers.\n *\n * @example\n * new Rect([left, top]) // width & height default to 0\n * new Rect(left, top) // width & height default to 0\n * new Rect(left, top, width, height)\n * new Rect([left, top], [width, height])\n * new Rect(oldRect) // clone of oldRect is created\n *\n * @property {Number} right\n * @property {Number} bottom\n * @property {Number} center\n * @constructor\n * @param {Array|gamejs.Rect} position Array holding left and top coordinates\n * @param {Array} dimensions Array holding width and height\n */\nvar Rect = exports.Rect = function() {\n\n   var args = normalizeRectArguments.apply(this, arguments);\n\n   /**\n    * Left, X coordinate\n    * @type Number\n    */\n   this.left = args.left;\n\n   /**\n    * Top, Y coordinate\n    * @type Number\n    */\n   this.top = args.top;\n\n   /**\n    * Width of rectangle\n    * @type Number\n    */\n   this.width = args.width;\n\n   /**\n    * Height of rectangle\n    * @type Number\n    */\n   this.height = args.height;\n\n   return this;\n};\n\nobjects.accessors(Rect.prototype, {\n   /**\n    * Bottom, Y coordinate\n    * @name Rect.prototype.bottom\n    * @type Number\n    */\n   'bottom': {\n      get: function() {\n         return this.top + this.height;\n      },\n      set: function(newValue) {\n         this.top = newValue - this.height;\n         return;\n      }\n   },\n   /**\n    * Right, X coordinate\n    * @name Rect.prototype.right\n    * @type Number\n    */\n   'right': {\n      get: function() {\n         return this.left + this.width;\n      },\n      set: function(newValue) {\n         this.left = newValue - this.width;\n      }\n   },\n   /**\n    * Center Position. You can assign a rectangle form.\n    * @name Rect.prototype.center\n    * @type Array\n    */\n   'center': {\n      get: function() {\n         return [this.left + (this.width / 2) | 0,\n                 this.top + (this.height / 2) | 0\n                ];\n      },\n      set: function() {\n         var args = normalizeRectArguments.apply(this, arguments);\n         this.left = args.left - (this.width / 2) | 0;\n         this.top = args.top - (this.height / 2) | 0;\n         return;\n      }\n   },\n   /**\n    * Top-left Position. You can assign a rectangle form.\n    * @name Rect.prototype.topleft\n    * @type Array\n    */\n   'topleft': {\n      get: function() {\n         return [this.left, this.top];\n      },\n      set: function() {\n         var args = normalizeRectArguments.apply(this, arguments);\n         this.left = args.left;\n         this.top = args.top;\n         return;\n      }\n   },\n   /**\n    * Bottom-left Position. You can assign a rectangle form.\n    * @name Rect.prototype.bottomleft\n    * @type Array\n    */\n   'bottomleft': {\n      get: function() {\n         return [this.left, this.bottom];\n      },\n      set: function() {\n         var args = normalizeRectArguments.apply(this, arguments);\n         this.left = args.left;\n         this.bottom = args.top;\n         return;\n      }\n   },\n   /**\n    * Top-right Position. You can assign a rectangle form.\n    * @name Rect.prototype.topright\n    * @type Array\n    */\n   'topright': {\n      get: function() {\n         return [this.right, this.top];\n      },\n      set: function() {\n         var args = normalizeRectArguments.apply(this, arguments);\n         this.right = args.left;\n         this.top = args.top;\n         return;\n      }\n   },\n   /**\n    * Bottom-right Position. You can assign a rectangle form.\n    * @name Rect.prototype.bottomright\n    * @type Array\n    */\n   'bottomright': {\n      get: function() {\n         return [this.right, this.bottom];\n      },\n      set: function() {\n         var args = normalizeRectArguments.apply(this, arguments);\n         this.right = args.left;\n         this.bottom = args.top;\n         return;\n      }\n   },\n   /**\n    * Position x value, alias for `left`.\n    * @name Rect.prototype.y\n    * @type Array\n    */\n   'x': {\n      get: function() {\n         return this.left;\n      },\n      set: function(newValue) {\n         this.left = newValue;\n         return;\n      }\n   },\n   /**\n    * Position y value, alias for `top`.\n    * @name Rect.prototype.y\n    * @type Array\n    */\n   'y': {\n      get: function() {\n         return this.top;\n      },\n      set: function(newValue) {\n         this.top = newValue;\n         return;\n      }\n   }\n});\n\n/**\n * Move returns a new Rect, which is a version of this Rect\n * moved by the given amounts. Accepts any rectangle form.\n * as argument.\n *\n * @param {Number|gamejs.Rect} x amount to move on x axis\n * @param {Number} y amount to move on y axis\n */\nRect.prototype.move = function() {\n   var args = normalizeRectArguments.apply(this, arguments);\n   return new Rect(this.left + args.left, this.top + args.top, this.width, this.height);\n};\n\n/**\n * Move this Rect in place - not returning a new Rect like `move(x, y)` would.\n *\n * `moveIp(x,y)` or `moveIp([x,y])`\n *\n * @param {Number|gamejs.Rect} x amount to move on x axis\n * @param {Number} y amount to move on y axis\n */\nRect.prototype.moveIp = function() {\n   var args = normalizeRectArguments.apply(this, arguments);\n   this.left += args.left;\n   this.top += args.top;\n   return;\n};\n\n/**\n * Return the area in which this Rect and argument Rect overlap.\n *\n * @param {gamejs.Rect} Rect to clip this one into\n * @returns {gamejs.Rect} new Rect which is completely inside the argument Rect,\n * zero sized Rect if the two rectangles do not overlap\n */\nRect.prototype.clip = function(rect) {\n   if(!this.collideRect(rect)) {\n      return new Rect(0,0,0,0);\n   }\n\n   var x, y, width, height;\n\n   // Left\n   if ((this.left >= rect.left) && (this.left < rect.right)) {\n      x = this.left;\n   } else if ((rect.left >= this.left) && (rect.left < this.right)) {\n      x = rect.left;\n   }\n\n   // Right\n   if ((this.right > rect.left) && (this.right <= rect.right)) {\n      width = this.right - x;\n   } else if ((rect.right > this.left) && (rect.right <= this.right)) {\n      width = rect.right - x;\n   }\n\n   // Top\n   if ((this.top >= rect.top) && (this.top < rect.bottom)) {\n      y = this.top;\n   } else if ((rect.top >= this.top) && (rect.top < this.bottom)) {\n      y = rect.top;\n   }\n\n   // Bottom\n   if ((this.bottom > rect.top) && (this.bottom <= rect.bottom)) {\n     height = this.bottom - y;\n   } else if ((rect.bottom > this.top) && (rect.bottom <= this.bottom)) {\n     height = rect.bottom - y;\n   }\n   return new Rect(x, y, width, height);\n};\n\n/**\n * Join two rectangles\n *\n * @param {gamejs.Rect} union with this rectangle\n * @returns {gamejs.Rect} rectangle containing area of both rectangles\n */\nRect.prototype.union = function(rect) {\n   var x, y, width, height;\n\n   x = Math.min(this.left, rect.left);\n   y = Math.min(this.top, rect.top);\n   width = Math.max(this.right, rect.right) - x;\n   height = Math.max(this.bottom, rect.bottom) - y;\n   return new Rect(x, y, width, height);\n};\n\n/**\n * Grow or shrink the rectangle size\n *\n * @param {Number} amount to change in the width\n * @param {Number} amount to change in the height\n * @returns {gamejs.Rect} inflated rectangle centered on the original rectangle's center\n */\nRect.prototype.inflate = function(x, y) {\n    var copy = this.clone();\n\n    copy.inflateIp(x, y);\n\n    return copy;\n};\n\n/**\n * Grow or shrink this Rect in place - not returning a new Rect like `inflate(x, y)` would.\n *\n * @param {Number} amount to change in the width\n * @param {Number} amount to change in the height\n */\nRect.prototype.inflateIp = function(x, y) {\n    // Use Math.floor here to deal with rounding of negative numbers the\n    // way this relies on.\n    this.left -= Math.floor(x / 2);\n    this.top -= Math.floor(y / 2);\n    this.width += x;\n    this.height += y;\n};\n\n/**\n * Check for collision with a point.\n *\n * `collidePoint(x,y)` or `collidePoint([x,y])` or `collidePoint(new Rect(x,y))`\n *\n * @param {Array|gamejs.Rect} point the x and y coordinates of the point to test for collision\n * @returns {Boolean} true if the point collides with this Rect\n */\nRect.prototype.collidePoint = function() {\n   var args = normalizeRectArguments.apply(this, arguments);\n   return (this.left <= args.left && args.left <= this.right) &&\n       (this.top <= args.top && args.top <= this.bottom);\n};\n\n/**\n * Check for collision with a Rect.\n * @param {gamejs.Rect} rect the Rect to test check for collision\n * @returns {Boolean} true if the given Rect collides with this Rect\n */\nRect.prototype.collideRect = function(rect) {\n   return !(this.left > rect.right || this.right < rect.left ||\n      this.top > rect.bottom || this.bottom < rect.top);\n};\n\n/**\n * @param {Array} pointA start point of the line\n * @param {Array} pointB end point of the line\n * @returns true if the line intersects with the rectangle\n * @see http://stackoverflow.com/questions/99353/how-to-test-if-a-line-segment-intersects-an-axis-aligned-rectange-in-2d/293052#293052\n *\n */\nRect.prototype.collideLine = function(p1, p2) {\n   var x1 = p1[0];\n   var y1 = p1[1];\n   var x2 = p2[0];\n   var y2 = p2[1];\n\n   function linePosition(point) {\n      var x = point[0];\n      var y = point[1];\n      return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2);\n   }\n\n   var relPoses = [[this.left, this.top],\n                   [this.left, this.bottom],\n                   [this.right, this.top],\n                   [this.right, this.bottom]\n                  ].map(linePosition);\n\n   var noNegative = true;\n   var noPositive = true;\n   var noZero = true;\n   relPoses.forEach(function(relPos) {\n      if (relPos > 0) {\n         noPositive = false;\n      } else if (relPos < 0) {\n         noNegative = false;\n      } else if (relPos === 0) {\n         noZero = false;\n      }\n   }, this);\n\n   if ( (noNegative || noPositive) && noZero) {\n      return false;\n   }\n   return !((x1 > this.right && x2 > this.right) ||\n            (x1 < this.left && x2 < this.left) ||\n            (y1 < this.top && y2 < this.top) ||\n            (y1 > this.bottom && y2 > this.bottom)\n            );\n};\n\n/**\n * @returns {String} Like \"[x, y][w, h]\"\n */\nRect.prototype.toString = function() {\n   return [\"[\", this.left, \",\", this.top, \"]\",\" [\",this.width, \",\", this.height, \"]\"].join(\"\");\n};\n\n/**\n * @returns {gamejs.Rect} A new copy of this rect\n */\nRect.prototype.clone = function() {\n   return new Rect(this);\n};\n\n/**\n * @ignore\n */\nexports.event = __webpack_require__(/*! ./gamejs/event */ \"./node_modules/gamejs/src/gamejs/event.js\");\n/**\n * @ignore\n */\nexports.font = __webpack_require__(/*! ./gamejs/font */ \"./node_modules/gamejs/src/gamejs/font.js\");\n/**\n * @ignore\n */\nexports.http = __webpack_require__(/*! ./gamejs/http */ \"./node_modules/gamejs/src/gamejs/http.js\");\n/**\n * @ignore\n */\nexports.image = __webpack_require__(/*! ./gamejs/image */ \"./node_modules/gamejs/src/gamejs/image.js\");\n/**\n * @ignore\n */\nexports.audio = __webpack_require__(/*! ./gamejs/audio */ \"./node_modules/gamejs/src/gamejs/audio.js\");\n/**\n * @ignore\n */\nexports.graphics = __webpack_require__(/*! ./gamejs/graphics */ \"./node_modules/gamejs/src/gamejs/graphics.js\");\n\n/**\n * @ignore\n */\nexports.logging = __webpack_require__(/*! ./gamejs/logging */ \"./node_modules/gamejs/src/gamejs/logging.js\");\n\n/**\n * @ignore\n */\nexports.math = {\n   matrix: __webpack_require__(/*! ./gamejs/math/matrix */ \"./node_modules/gamejs/src/gamejs/math/matrix.js\"),\n   vectors: __webpack_require__(/*! ./gamejs/math/vectors */ \"./node_modules/gamejs/src/gamejs/math/vectors.js\"),\n   angles: __webpack_require__(/*! ./gamejs/math/angles */ \"./node_modules/gamejs/src/gamejs/math/angles.js\"),\n   binaryheap: __webpack_require__(/*! ./gamejs/math/binaryheap */ \"./node_modules/gamejs/src/gamejs/math/binaryheap.js\"),\n   random: __webpack_require__(/*! ./gamejs/math/random */ \"./node_modules/gamejs/src/gamejs/math/random.js\"),\n   noise: __webpack_require__(/*! ./gamejs/math/noise */ \"./node_modules/gamejs/src/gamejs/math/noise.js\"),\n};\n\n/**\n * @ignore\n */\nexports.utils = {\n   arrays: __webpack_require__(/*! ./gamejs/utils/arrays */ \"./node_modules/gamejs/src/gamejs/utils/arrays.js\"),\n   objects: __webpack_require__(/*! ./gamejs/utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\"),\n   uri: __webpack_require__(/*! ./gamejs/utils/uri */ \"./node_modules/gamejs/src/gamejs/utils/uri.js\"),\n   strings: __webpack_require__(/*! ./gamejs/utils/strings */ \"./node_modules/gamejs/src/gamejs/utils/strings.js\"),\n   xml: __webpack_require__(/*! ./gamejs/utils/xml */ \"./node_modules/gamejs/src/gamejs/utils/xml.js\"),\n   base64: __webpack_require__(/*! ./gamejs/utils/base64 */ \"./node_modules/gamejs/src/gamejs/utils/base64.js\")\n};\n/**\n * @ignore\n */\nexports.display = __webpack_require__(/*! ./gamejs/display */ \"./node_modules/gamejs/src/gamejs/display.js\");\n/**\n * @ignore\n */\nexports.pathfinding = __webpack_require__(/*! ./gamejs/pathfinding */ \"./node_modules/gamejs/src/gamejs/pathfinding.js\");\n\n\n/**\n * @ignore\n */\nexports.tiledmap = __webpack_require__(/*! ./gamejs/tiledmap */ \"./node_modules/gamejs/src/gamejs/tiledmap.js\");\n\n\n/**\n * @ignore\n */\nexports.time = __webpack_require__(/*! ./gamejs/time */ \"./node_modules/gamejs/src/gamejs/time.js\");\n\n/**\n * @ignore\n */\nexports.pixelcollision = __webpack_require__(/*! ./gamejs/pixelcollision */ \"./node_modules/gamejs/src/gamejs/pixelcollision.js\");\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/audio.js":
/*!*************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/audio.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\n\n/**\n * @fileoverview Playing sounds with the html5 audio tag. Audio files must be preloaded\n * with the usual `gamejs.preload()` function. Ogg, wav and webm supported.\n *\n */\n\nvar CACHE = {};\n\n/**\n * need to export preloading status for require\n * @ignore\n */\nvar _PRELOADING = false;\n\n/**\n * @ignore\n */\nvar NUM_CHANNELS = 8;\n\n/**\n * Sets the number of available channels for the mixer. The default value is 8.\n */\nexports.setNumChannels = function(count) {\n   NUM_CHANNELS = parseInt(count, 10) || NUM_CHANNELS;\n};\n\nexports.getNumChannels = function() {\n   return NUM_CHANNELS;\n};\n\n/**\n * put all audios on page in cache\n * if same domain as current page, remove common href-prefix\n * @ignore\n */\nexports.init = function() {\n   var audios = Array.prototype.slice.call(document.getElementsByTagName(\"audio\"), 0);\n   addToCache(audios);\n   return;\n};\n\n/**\n * Preload the audios into cache\n * @param {String[]} List of audio URIs to load\n * @returns {Function} which returns 0-1 for preload progress\n * @ignore\n */\nexports.preload = function(audioUrls, showProgressOrImage) {\n   var countTotal = 0;\n   var countLoaded = 0;\n\n   function incrementLoaded() {\n      countLoaded++;\n      if (countLoaded == countTotal) {\n         _PRELOADING = false;\n      }\n   }\n\n   function getProgress() {\n      return countTotal > 0 ? countLoaded / countTotal : 1;\n   }\n\n   function successHandler() {\n      addToCache(this);\n      incrementLoaded();\n   }\n   function errorHandler() {\n      incrementLoaded();\n      throw new Error('Error loading ' + this.src);\n   }\n\n   for (var key in audioUrls) {\n      if (key.indexOf('wav') == -1 && key.indexOf('ogg') == -1 && key.indexOf('webm') == -1) {\n         continue;\n      }\n      countTotal++;\n      var audio = new Audio();\n      audio.addEventListener('canplay', successHandler, true);\n      audio.addEventListener('error', errorHandler, true);\n      audio.src = audioUrls[key];\n      audio.gamejsKey = key;\n      audio.load();\n   }\n   if (countTotal > 0) {\n      _PRELOADING = true;\n   }\n   return getProgress;\n};\n\n/**\n * @ignore\n */\nexports.isPreloading = function() {\n   return _PRELOADING;\n};\n\n/**\n * @param {dom.ImgElement} audios the <audio> elements to put into cache\n * @ignore\n */\nfunction addToCache(audios) {\n   if (!(audios instanceof Array)) {\n      audios = [audios];\n   }\n\n   var docLoc = document.location.href;\n   audios.forEach(function(audio) {\n      CACHE[audio.gamejsKey] = audio;\n   });\n   return;\n}\n\n/**\n * Sounds can be played back.\n * @constructor\n * @param {String|dom.AudioElement} uriOrAudio the uri of <audio> dom element\n *                of the sound\n */\nexports.Sound = function Sound(uriOrAudio) {\n   var cachedAudio;\n   if (typeof uriOrAudio === 'string') {\n      cachedAudio = CACHE[uriOrAudio];\n   } else {\n      cachedAudio = uriOrAudio;\n   }\n   if (!cachedAudio) {\n      // TODO sync audio loading\n      throw new Error('Missing \"' + uriOrAudio + '\", gamejs.preload() all audio files before loading');\n   }\n\n   var channels = [];\n   var i = NUM_CHANNELS;\n   while (i-->0) {\n      var audio = new Audio();\n      audio.preload = \"auto\";\n      audio.loop = false;\n      audio.src = cachedAudio.src;\n      channels.push(audio);\n   }\n   /**\n    * start the sound\n    * @param {Boolean} loop whether the audio should loop for ever or not\n    */\n   this.play = function(loop) {\n      channels.some(function(audio) {\n         if (audio.ended || audio.paused) {\n            audio.loop = !!loop;\n            audio.play();\n            return true;\n         }\n         return false;\n      });\n   };\n\n   /**\n    * Stop the sound.\n    * This will stop the playback of this Sound on any active Channels.\n    */\n   this.stop = function() {\n      channels.forEach(function(audio) {\n         audio.stop();\n      });\n   };\n\n   /**\n    * Set volume of this sound\n    * @param {Number} value volume from 0 to 1\n    */\n   this.setVolume = function(value) {\n      channels.forEach(function(audio) {\n         audio.volume = value;\n      });\n   };\n\n   /**\n    * @returns {Number} the sound's volume from 0 to 1\n    */\n   this.getVolume = function() {\n      return channels[0].volume;\n   };\n\n   /**\n    * @returns {Number} Duration of this sound in seconds\n    */\n   this.getLength = function() {\n      return channels[0].duration;\n   };\n\n   return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/audio.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/display.js":
/*!***************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/display.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Surface = __webpack_require__(/*! ./graphics */ \"./node_modules/gamejs/src/gamejs/graphics.js\").Surface;\n\n/**\n * @fileoverview Methods to create, access and manipulate the display Surface.\n *\n * You can just grab the canvas element whether it exists in the DOM or not (GameJs\n * will create it if necessary):\n *\n *     var display = gamejs.display.getSurface();\n *\n * If you need to resize the canvas - although it is recommended to style it with CSS - you can\n * call the `setMode()` function, which conviniently returns the new display surface:\n *\n *     newDisplay = gamejs.display.setMode([800, 600]);\n *\n * ### Browser window gets resized\n *\n * When the canvas size is configured with CSS, the display surface might change when\n * the browser window is resized. GameJs will internally deal with this and recreate\n * the the display surface with the new size.\n *\n * You will typically not have to worry about this but if you want to get informed\n * about a display resize, you can register a callback with `gamejs.event.onDisplayResize`.\n *\n *\n * ### Flags\n *\n * For advanced uses you can set a few modes which additionally change how the display\n * behaves with regards to pixel smoothing and whether you want a fullscreen canvas with\n * or withouth the mouse pointer locked inside the window (for endless mouse movement in\n * all directions).\n *\n *\n * `gamejs.display.setMode()` understands three flags:\n *\n *   * gamejs.display.FULLSCREEN\n *   * gamejs.display.DISABLE_SMOOTHING\n *   * gamejs.display.POINTERLOCK (implies FULLSCREEN)\n *\n * For example:\n *      // disable smoothing\n *      gamejs.display.setMode([800, 600], gamejs.display.DISABLE_SMOOTHING);\n *      // disable smoothing and fullscreen\n *      gamejs.display.setMode(\n               [800, 600],\n               gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN\n         );\n *\n * ### Fullscreen mode\n *\n * When `setMode()` is called with the fullscreen flag then the fullscreen mode can be enabled by the\n * player by clicking on the DOM element with id \"gjs-fullscreen-toggle\". Browser security requires\n * that a user enables fullscreen with a \"gesture\" (e.g., clicking a button) and we can not enable fullscreen\n * in code.\n *\n * Fullscreen mode can be exited by many keys, e.g., anything window manager related (ALT-TAB) or ESC. A lot\n * of keys will trigger a browser information popup explaining how fullscreen mode can be exited.\n *\n * The following keys are \"whitelisted\" in fullscreen mode and will not trigger such a browser popup:\n *\n *  * left arrow, right arrow, up arrow, down arrow\n *  * space\n *  * shift, control, alt\n *  * page up, page down\n *  * home, end, tab, meta\n *\n *\n * ### Relevant DOM node ids accessed by this module\n *\n * You can provide your own tags with those ids\n *\n *   * gjs-canvas - the display surface\n *   * gjs-loader - loading bar\n *   * gjs-fullscreen-toggle a clickable element to enable fullscreen\n *   * gjs-canvas-wrapper this wrapper is added when in fullscreen mode\n *\n */\n\nvar CANVAS_ID = \"gjs-canvas\";\nvar LOADER_ID = \"gjs-loader\";\nvar SURFACE = null;\n\n/**\n * Pass this flag to `gamejs.display.setMode(resolution, flags)` to disable\n * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics\n * where you don't want the browser to smooth them when scaling & drawing.\n */\nvar DISABLE_SMOOTHING = exports.DISABLE_SMOOTHING = 2;\nvar FULLSCREEN = exports.FULLSCREEN = 4;\nvar POINTERLOCK = exports.POINTERLOCK = 8;\n\nvar _flags = 0;\n\n/**\n * @returns {document.Element} the canvas dom element\n * @ignore\n */\nvar getCanvas = exports._getCanvas = function() {\n   var displayCanvas = document.getElementById(CANVAS_ID);\n   if (!displayCanvas) {\n      displayCanvas = document.createElement(\"canvas\");\n      displayCanvas.setAttribute(\"id\", CANVAS_ID);\n      document.body.appendChild(displayCanvas);\n   }\n   return displayCanvas;\n};\n\n\nvar getFullScreenToggle = function() {\n   var fullScreenButton = document.getElementById('gjs-fullscreen-toggle');\n   if (!fullScreenButton) {\n      // before canvas\n      fullScreenButton = document.createElement('button');\n      fullScreenButton.innerHTML = 'Fullscreen';\n      fullScreenButton.id = 'gjs-fullscreen-toggle';\n      var canvas = getCanvas();\n      canvas.parentNode.insertBefore(fullScreenButton, canvas);\n      canvas.parentNode.insertBefore(document.createElement('br'), canvas);\n\n   }\n   return fullScreenButton;\n};\n\nvar fullScreenChange = function(event) {\n   var gjsEvent ={\n      type: isFullScreen() ? __webpack_require__(/*! ./event */ \"./node_modules/gamejs/src/gamejs/event.js\").DISPLAY_FULLSCREEN_ENABLED :\n                        __webpack_require__(/*! ./event */ \"./node_modules/gamejs/src/gamejs/event.js\").DISPLAY_FULLSCREEN_DISABLED\n\n   };\n   if (isFullScreen()) {\n      if (_flags & POINTERLOCK) {\n         enablePointerLock();\n      }\n   }\n   __webpack_require__(/*! ./event */ \"./node_modules/gamejs/src/gamejs/event.js\")._triggerCallbacks(gjsEvent);\n};\n\nexports.hasPointerLock = function() {\n   return !!(document.pointerLockElement ||\n      document.webkitFullscreenElement ||\n      document.mozFullscreenElement ||\n      document.mozFullScreenElement);\n};\n\nfunction onResize(event) {\n   var canvas = getCanvas();\n   SURFACE._canvas.width = canvas.clientWidth;\n   SURFACE._canvas.height = canvas.clientHeight;\n   __webpack_require__(/*! ./event */ \"./node_modules/gamejs/src/gamejs/event.js\")._triggerCallbacks({\n      type: __webpack_require__(/*! ./event */ \"./node_modules/gamejs/src/gamejs/event.js\").DISPLAY_RESIZE\n   });\n}\n\n/**\n * Create the master Canvas plane.\n * @ignore\n */\nexports.init = function() {\n   // create canvas element if not yet present\n   var canvas = getCanvas();\n   if (!canvas.getAttribute('tabindex')) {\n      // to be focusable, tabindex must be set\n      canvas.setAttribute(\"tabindex\", 1);\n      canvas.focus();\n   }\n   // remove loader if any;\n   var $loader = document.getElementById(LOADER_ID);\n   if ($loader) {\n      $loader.style.display = \"none\";\n   }\n   var $displaySurface = document.getElementById(CANVAS_ID);\n   if ($displaySurface) {\n      $displaySurface.style.display = 'block';\n   }\n   // hook into resize\n   window.addEventListener(\"resize\", onResize, false);\n   return;\n};\n\nvar isFullScreen = exports.isFullscreen = function() {\n   return (document.fullScreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.webkitDisplayingFullscreen);\n};\n\n/**\n * Switches the display window normal browser mode and fullscreen.\n * @ignore\n * @returns {Boolean} true if operation was successfull, false otherwise\n */\nvar enableFullScreen = function(event) {\n   var wrapper = getCanvas();\n   wrapper.requestFullScreen = wrapper.requestFullScreen || wrapper.mozRequestFullScreen || wrapper.webkitRequestFullScreen;\n   if (!wrapper.requestFullScreen) {\n      return false;\n   }\n   // @xbrowser chrome allows keboard input onl if ask for it (why oh why?)\n   if (Element.ALLOW_KEYBOARD_INPUT) {\n      wrapper.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);\n   } else {\n      wrapper.requestFullScreen();\n   }\n   return true;\n};\n\nvar enablePointerLock = function() {\n   var wrapper = getCanvas();\n   wrapper.requestPointerLock = wrapper.requestPointerLock || wrapper.mozRequestPointerLock || wrapper.webkitRequestPointerLock;\n   if (wrapper.requestPointerLock) {\n      wrapper.requestPointerLock();\n   }\n};\n\n/** @ignore **/\nexports._hasFocus = function() {\n   return document.activeElement == getCanvas();\n};\n\n/**\n * Set the width and height of the Display. Conviniently this will\n * return the actual display Surface - the same as calling [gamejs.display.getSurface()](#getSurface)\n * later on.\n * @param {Array} dimensions [width, height] of the display surface\n * @param {Number} flags gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN | gamejs.display.POINTERLOCK\n */\nexports.setMode = function(dimensions, flags) {\n   SURFACE = null;\n   var canvas = getCanvas();\n   canvas.width = canvas.clientWidth = dimensions[0];\n   canvas.height = canvas.clientHeight = dimensions[1];\n\n   _flags = _flags || flags;\n   // @ xbrowser firefox allows pointerlock only if fullscreen\n   if (_flags & POINTERLOCK) {\n      _flags = _flags | FULLSCREEN;\n   }\n   if (_flags & FULLSCREEN) {\n      // attach fullscreen toggle checkbox\n      var fullScreenToggle = getFullScreenToggle();\n      fullScreenToggle.removeEventListener('click', enableFullScreen, false);\n      fullScreenToggle.addEventListener('click', enableFullScreen, false);\n      // @@ xbrowser\n      document.removeEventListener('fullScreenchange',fullScreenChange, false);\n      document.removeEventListener('webkitfullscreenchange',fullScreenChange, false);\n      document.removeEventListener('mozfullscreenchange',fullScreenChange, false);\n      document.addEventListener('fullscreenchange', fullScreenChange, false);\n      document.addEventListener('webkitfullscreenchange', fullScreenChange, false);\n      document.addEventListener('mozfullscreenchange', fullScreenChange, false);\n   }\n   return getSurface(dimensions);\n};\n\n/**\n * Set the Caption of the Display (document.title)\n * @param {String} title the title of the app\n * @param {gamejs.Image} icon FIXME implement favicon support\n */\nexports.setCaption = function(title, icon) {\n   document.title = title;\n};\n\n/** @ignore **/\nexports._isSmoothingEnabled = function() {\n   return !(_flags & DISABLE_SMOOTHING);\n};\n\n/**\n * The Display (the canvas element) is most likely not in the top left corner\n * of the browser due to CSS styling. To calculate the mouseposition within the\n * canvas we need this offset.\n * @see gamejs/event\n * @ignore\n *\n * @returns {Array} [x, y] offset of the canvas\n */\n\nexports._getCanvasOffset = function() {\n   var boundRect = getCanvas().getBoundingClientRect();\n   return [boundRect.left, boundRect.top];\n};\n\n/**\n * Drawing on the Surface returned by `getSurface()` will draw on the screen.\n * @returns {gamejs.Surface} the display Surface\n */\nvar getSurface = exports.getSurface = function(dimensions) {\n   if (SURFACE === null) {\n      var canvas = getCanvas();\n      if (dimensions === undefined) {\n         dimensions = [canvas.clientWidth, canvas.clientHeight];\n      }\n      SURFACE = new Surface(dimensions);\n      SURFACE._canvas = canvas;\n      SURFACE._canvas.width = dimensions[0];\n      SURFACE._canvas.height = dimensions[1];\n      SURFACE._context = canvas.getContext('2d');\n      if (!(_flags & DISABLE_SMOOTHING)) {\n         SURFACE._smooth();\n      } else {\n         SURFACE._noSmooth();\n      }\n   }\n   return SURFACE;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/display.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/event.js":
/*!*************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/event.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var display = __webpack_require__(/*! ./display */ \"./node_modules/gamejs/src/gamejs/display.js\");\nvar Callback = __webpack_require__(/*! ./utils/callback */ \"./node_modules/gamejs/src/gamejs/utils/callback.js\").Callback;\n\n/**\n * @fileoverview\n * Deal with mouse and keyboard events.\n *\n * You can either handle all events in one callback with `gamejs.event.onEvent()`:\n *\n *     gamejs.onEvent(function(event) {\n *        if (event.type === gamejs.event.MOUSE_UP) {\n *          gamejs.logging.info(event.pos, event.button);\n *        } else if (event.type === gamejs.event.KEY_UP) {\n *          gamejs.logging.info(event.key);\n *        }\n *     });\n *\n * Or recieve more specific callbacks, e.g. only for `KEY\\_UP` with  `gamejs.event.onKeyUp()`:\n *\n *     gamejs.onKeyUp(function(event) {\n *          gamejs.logging.info(event.key);\n *     });\n *\n * All events passed to your callback are instances of `gamejs.event.Event` and have a `type` property to help\n * you distinguish between the different events. This `type` property is set to one of those constants:\n *\n *  * gamejs.event.MOUSE\\_UP\n *  * gamejs.event.MOUSE\\_MOTION\n *  * gamejs.event.MOUSE\\_DOWN\n *  * gamejs.event.KEY\\_UP\n *  * gamejs.event.KEY\\_DOWN\n *  * gamejs.event.DISPLAY\\_FULLSCREEN\\_ENABLED\n *  * gamejs.event.DISPLAY\\_FULLSCREEN\\_DISABLED\n *  * gamejs.event.QUIT\n *  * gamejs.event.MOUSE_WHEEL\n *  * gamejs.event.TOUCH\\_DOWN\n *  * gamejs.event.TOUCH\\_UP\n *  * gamejs.event.TOUCH\\_MOTION\n *\n * ### Keyboard constants\n *\n * There are also a lot of keyboard constants for ASCII. Those are all prefixed with `K\\_`, e.g. `gamejs.event.K\\_a` would be the \"a\"\n * key and `gamejs.event.K_SPACE` is the spacebar.\n *\n * ## Touch events\n *\n * Touch events do not have a single position but for all `TOUCH\\_*` events you get an array of\n * `touches`, which each have their own `pos` attribute and a unique `identifier` for tracking\n * this touch across multiple `TOUCH\\_MOTION` events.\n *\n * ## User defined events\n *\n * All user defined events can have the value of `gamejs.event.USEREVENT` or higher.\n * Make sure your custom event ids follow this system.\n *\n * @example\n *     gamejs.onEvent(function(event) {\n *        if (event.type === gamejs.event.MOUSE_UP) {\n *          gamejs.logging.log(event.pos, event.button);\n *        } else if (event.type === gamejs.event.KEY_UP) {\n *          gamejs.logging.log(event.key);\n *        }\n *     });\n *\n */\n\nvar _CALLBACKS = [];\n\n/** @ignore **/\nvar _triggerCallbacks = exports._triggerCallbacks = function() {\n  var args = arguments;\n  _CALLBACKS.forEach(function(cb) {\n    if (cb.type === 'all' || args[0].type === cb.type) {\n      cb.callback.apply(cb.scope, args);\n    }\n  });\n};\n\n/*\nexports.onQuit(callback)\nexports.onVisiblityChange(callback)\n*/\n\n/**\n * Pass a callback function to be called when Fullscreen is enabled or disabled.\n * Inspect `event.type` to distinguis between entering and exiting fullscreen.\n *\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onFullscreen = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n   _CALLBACKS.push({\n      callback: callback,\n      scope: scope,\n      type: exports.DISPLAY_FULLSCREEN_ENABLED\n   });\n   _CALLBACKS.push({\n      callback: callback,\n      scope: scope,\n      type: exports.DISPLAY_FULLSCREEN_DISABLED\n   });\n};\n\n/**\n * The function passsed to `onEvent` will be called whenever\n * any event (mouse, keyboard, etc) was triggered.\n *\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onEvent = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: 'all'\n  });\n};\n\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onDisplayResize = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   };\n\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.DISPLAY_RESIZE\n  });\n}\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onMouseMotion = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.MOUSE_MOTION\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onMouseUp = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.MOUSE_UP\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onMouseDown = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.MOUSE_DOWN\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onTouchMotion = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.TOUCH_MOTION\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onTouchUp = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.TOUCH_UP\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onTouchDown = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.TOUCH_DOWN\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onKeyDown = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.KEY_DOWN\n  });\n};\n\n/**\n * @param {Function} callback to be called\n * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)\n */\nexports.onKeyUp = function(callback, scope) {\n   if (typeof(callback) !== 'function') {\n      throw new Error('Callback must be a function');\n   }\n  _CALLBACKS.push({\n    callback: callback,\n    scope: scope,\n    type: exports.KEY_UP\n  });\n};\n\n// key constants\nexports.K_UP = 38;\nexports.K_DOWN = 40;\nexports.K_RIGHT = 39;\nexports.K_LEFT = 37;\n\nexports.K_SPACE = 32;\nexports.K_BACKSPACE = 8;\nexports.K_TAB = 9;\nexports.K_ENTER = 13;\nexports.K_SHIFT = 16;\nexports.K_CTRL = 17;\nexports.K_ALT = 18;\nexports.K_ESC = 27;\n\nexports.K_0 = 48;\nexports.K_1 = 49;\nexports.K_2 = 50;\nexports.K_3 = 51;\nexports.K_4 = 52;\nexports.K_5 = 53;\nexports.K_6 = 54;\nexports.K_7 = 55;\nexports.K_8 = 56;\nexports.K_9 = 57;\nexports.K_a = 65;\nexports.K_b = 66;\nexports.K_c = 67;\nexports.K_d = 68;\nexports.K_e = 69;\nexports.K_f = 70;\nexports.K_g = 71;\nexports.K_h = 72;\nexports.K_i = 73;\nexports.K_j = 74;\nexports.K_k = 75;\nexports.K_l = 76;\nexports.K_m = 77;\nexports.K_n = 78;\nexports.K_o = 79;\nexports.K_p = 80;\nexports.K_q = 81;\nexports.K_r = 82;\nexports.K_s = 83;\nexports.K_t = 84;\nexports.K_u = 85;\nexports.K_v = 86;\nexports.K_w = 87;\nexports.K_x = 88;\nexports.K_y = 89;\nexports.K_z = 90;\n\nexports.K_KP1 = 97;\nexports.K_KP2 = 98;\nexports.K_KP3 = 99;\nexports.K_KP4 = 100;\nexports.K_KP5 = 101;\nexports.K_KP6 = 102;\nexports.K_KP7 = 103;\nexports.K_KP8 = 104;\nexports.K_KP9 = 105;\n\n// event type constants\nexports.NOEVENT = 0;\nexports.NUMEVENTS = 32000;\n\nexports.DISPLAY_FULLSCREEN_ENABLED = 300;\nexports.DISPLAY_FULLSCREEN_DISABLED = 301;\nexports.DISPLAY_RESIZE = 302;\n\nexports.QUIT = 0;\nexports.KEY_DOWN = 1;\nexports.KEY_UP = 2;\nexports.MOUSE_MOTION = 3;\nexports.MOUSE_UP = 4;\nexports.MOUSE_DOWN = 5;\nexports.MOUSE_WHEEL = 6;\nexports.TOUCH_UP = 7;\nexports.TOUCH_DOWN = 8;\nexports.TOUCH_MOTION = 9;\nexports.USEREVENT = 2000;\n\n\n\n/**\n * Properties of the `event` object argument passed to the callbacks.\n * @class\n */\n\nexports.Event = function() {\n    /**\n     * The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.\n     */\n    this.type = null;\n    /**\n     * key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...\n     */\n    this.key = null;\n    /**\n     * relative movement for a mousemove event\n     */\n    this.rel = null;\n    /**\n     * the number of the mousebutton pressed\n     */\n    this.button = null;\n    /**\n     * pos the position of the event for mouse events\n     */\n    this.pos = null;\n};\n\n/**\n * @ignore\n */\nexports.init = function() {\n\n   var lastPos = [];\n\n   // anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener\n\n   function onMouseDown (ev) {\n      var canvasOffset = display._getCanvasOffset();\n      _triggerCallbacks({\n         'type': exports.MOUSE_DOWN,\n         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],\n         'button': ev.button,\n         'shiftKey': ev.shiftKey,\n         'ctrlKey': ev.ctrlKey,\n         'metaKey': ev.metaKey\n      });\n   }\n\n   function onMouseUp (ev) {\n      var canvasOffset = display._getCanvasOffset();\n      _triggerCallbacks({\n         'type':exports.MOUSE_UP,\n         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],\n         'button': ev.button,\n         'shiftKey': ev.shiftKey,\n         'ctrlKey': ev.ctrlKey,\n         'metaKey': ev.metaKey\n      });\n   }\n\n   function onKeyDown (ev) {\n      var key = ev.keyCode || ev.which;\n      _triggerCallbacks({\n         'type': exports.KEY_DOWN,\n         'key': key,\n         'shiftKey': ev.shiftKey,\n         'ctrlKey': ev.ctrlKey,\n         'metaKey': ev.metaKey\n      });\n\n      // if the display has focus, we surpress default action\n      // for most keys\n      if (display._hasFocus() && (!ev.ctrlKey && !ev.metaKey &&\n         ((key >= exports.K_LEFT && key <= exports.K_DOWN) ||\n         (key >= exports.K_0    && key <= exports.K_z) ||\n         (key >= exports.K_KP1  && key <= exports.K_KP9) ||\n         key === exports.K_SPACE ||\n         key === exports.K_TAB ||\n         key === exports.K_ENTER)) ||\n         key === exports.K_ALT ||\n         key === exports.K_BACKSPACE) {\n        ev.preventDefault();\n      }\n   }\n\n   function onKeyUp (ev) {\n      _triggerCallbacks({\n         'type': exports.KEY_UP,\n         'key': ev.keyCode,\n         'shiftKey': ev.shiftKey,\n         'ctrlKey': ev.ctrlKey,\n         'metaKey': ev.metaKey\n      });\n   }\n\n   function onMouseMove (ev) {\n      var canvasOffset = display._getCanvasOffset();\n      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];\n      var relativePos = [];\n      if (lastPos.length) {\n         relativePos = [\n            lastPos[0] - currentPos[0],\n            lastPos[1] - currentPos[1]\n         ];\n      }\n      _triggerCallbacks({\n         'type': exports.MOUSE_MOTION,\n         'pos': currentPos,\n         'rel': relativePos,\n         'buttons': null, // FIXME, fixable?\n         'timestamp': ev.timeStamp,\n         'movement': [ev.movementX       ||\n                      ev.mozMovementX    ||\n                      ev.webkitMovementX || 0,\n                      ev.movementY       ||\n                      ev.mozMovementY    ||\n                      ev.webkitMovementY || 0\n                      ]\n      });\n      lastPos = currentPos;\n      return;\n   }\n\n   function onMouseScroll(ev) {\n      var canvasOffset = display._getCanvasOffset();\n      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];\n      _triggerCallbacks({\n         type: exports.MOUSE_WHEEL,\n         pos: currentPos,\n         delta: ev.detail || (- ev.wheelDeltaY / 40)\n      });\n      return;\n   }\n\n   function onBeforeUnload (ev) {\n      _triggerCallbacks({\n         'type': exports.QUIT\n      });\n      return;\n   };\n\n   // convert a w3c touch event into gamejs event\n   function w3cTouchConvert(touchList) {\n      var canvasOffset = display._getCanvasOffset();\n      var tList = [];\n      for (var i = 0; i < touchList.length; i++) {\n         var touchEvent = touchList.item(i);\n         tList.push({\n            identifier: touchEvent.identifier,\n            pos: [touchEvent.clientX - canvasOffset[0], touchEvent.clientY - canvasOffset[1]]\n         });\n      }\n      return tList;\n   }\n\n   function onTouchDown(ev) {\n      var canvasOffset = display._getCanvasOffset();\n      var changedTouches = w3cTouchConvert(ev.changedTouches);\n      _triggerCallbacks({\n         'type': exports.TOUCH_DOWN,\n         'touches': changedTouches\n      });\n   };\n\n   function onTouchUp(ev) {\n      var changedTouches = w3cTouchConvert(ev.changedTouches);\n      _triggerCallbacks({\n         'type': exports.TOUCH_UP,\n         'touches': changedTouches,\n      });\n   }\n   function onTouchMotion(ev) {\n      var changedTouches = w3cTouchConvert(ev.changedTouches);\n      _triggerCallbacks({\n         'type': exports.TOUCH_MOTION,\n         'touches': changedTouches\n      });\n      ev.preventDefault();\n   }\n\n   // IE does not support addEventListener on document itself\n   // FX events don't reach body if mouse outside window or on menubar\n   var canvas = display._getCanvas();\n   document.addEventListener('mousedown', onMouseDown, false);\n   document.addEventListener('mouseup', onMouseUp, false);\n   document.addEventListener('keydown', onKeyDown, false);\n   document.addEventListener('keyup', onKeyUp, false);\n   document.addEventListener('mousemove', onMouseMove, false);\n   canvas.addEventListener('mousewheel', onMouseScroll, false);\n   // MOZFIX\n   // https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events\n   canvas.addEventListener('DOMMouseScroll', onMouseScroll, false);\n   canvas.addEventListener('beforeunload', onBeforeUnload, false);\n   // touchs\n   canvas.addEventListener(\"touchstart\", onTouchDown, false);\n   canvas.addEventListener(\"touchend\", onTouchUp, false);\n   canvas.addEventListener(\"touchcancel\", onTouchUp, false);\n   canvas.addEventListener(\"touchleave\", onTouchUp, false);\n   canvas.addEventListener(\"touchmove\", onTouchMotion, false);\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/event.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/font.js":
/*!************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/font.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Surface = __webpack_require__(/*! ./graphics */ \"./node_modules/gamejs/src/gamejs/graphics.js\").Surface;\nvar objects = __webpack_require__(/*! ./utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\");\n\n/**\n * @fileoverview Methods for creating Font objects which can render text\n * to a Surface.\n *\n * @example\n * var font = new Font('20px monospace');\n * // render text - this returns a surface with the text written on it.\n * var helloSurface = font.render('Hello World')\n */\n\n/**\n * Create a Font to draw on the screen. The Font allows you to\n * `render()` text. Rendering text returns a Surface which\n * in turn can be put on screen.\n *\n * @constructor\n * @property {Number} fontHeight the line height of this Font\n *\n * @param {String} fontSettings a css font definition, e.g., \"20px monospace\"\n * @param {STring} backgroundColor valid #rgb string, \"#ff00cc\"\n */\nvar Font = exports.Font = function(fontSettings, backgroundColor) {\n    /**\n     * @ignore\n     */\n   this.sampleSurface = new Surface([10,10]);\n   this.sampleSurface.context.font = fontSettings;\n   this.sampleSurface.context.textAlign = 'start';\n   // http://diveintohtml5.org/canvas.html#text\n   this.sampleSurface.context.textBaseline = 'bottom';\n   this.backgroundColor = backgroundColor || false;\n   return this;\n};\n\n/**\n * Returns a Surface with the given text on it.\n * @param {String} text the text to render\n * @param {String} color a valid #RGB String, \"#ffcc00\"\n * @returns {gamejs.Surface} Surface with the rendered text on it.\n */\nFont.prototype.render = function(text, color) {\n   var dims = this.size(text);\n   var surface = new Surface(dims);\n   var ctx = surface.context;\n   ctx.save();\n   if ( this.backgroundColor ) {\n       ctx.fillStyle = this.backgroundColor;\n       ctx.fillRect(0, 0, surface.rect.width, surface.rect.height);\n   }\n   ctx.font = this.sampleSurface.context.font;\n   ctx.textBaseline = this.sampleSurface.context.textBaseline;\n   ctx.textAlign = this.sampleSurface.context.textAlign;\n   ctx.fillStyle = ctx.strokeStyle = color || \"#000000\";\n   ctx.fillText(text, 0, surface.rect.height, surface.rect.width);\n   ctx.restore();\n   return surface;\n};\n\n/**\n * Determine the width and height of the given text if rendered\n * with this Font.\n * @param {String} text the text to measure\n * @returns {Array} the [width, height] of the text if rendered with this Font\n */\nFont.prototype.size = function(text) {\n   var metrics = this.sampleSurface.context.measureText(text);\n   // FIXME measuretext is buggy, make extra wide\n   return [metrics.width, this.fontHeight];\n};\n\n/**\n * Height of the font in pixels.\n */\nobjects.accessors(Font.prototype, {\n   'fontHeight': {\n      get: function() {\n         // Returns an approximate line height of the text\n         // This version of the specification does not provide a way to obtain\n         // the bounding box dimensions of the text.\n         // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-measuretext\n         return this.sampleSurface.context.measureText('M').width * 1.5;\n      }\n   }\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/font.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/graphics.js":
/*!****************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/graphics.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview\n * This module holds the important `Surface` class which is the general container for image data.\n *\n *     var surface = new gamejs.graphics.Surface([width, height]);\n *\n * The functions\n * to draw geometric lines like circles, lines, rectangles, etc. are also all in this module:\n *\n *     gamejs.graphics.line(surface, '#ff0000', centerPoint, radius);\n *\n * Each Surface instance has methods to create *a new* rotated, flipped, scaled, etc. instance of itself:\n *\n *     // the original `surface` remains untouched by the\n *     // filp operation. A new Surface instance\n *     // is returned by `flip()`.\n *     var horizontalFlippedSurface = surface.flip(true);\n *\n * If you want to put images (png, jpg) on the screen, also see the `gamejs.image` module and `gamejs.preload()`.\n *\n * There are several ways to specify colors. Whenever the docs says \"valid #RGB string\"\n * you can pass in any of the following formats: `\"#ff00ff\"`, `\"rgb(255, 0, 255)\"` or `\"rgba(255, 0, 255, 1)\"`.\n *\n * @see gamejs/image\n */\nvar gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar Rect = gamejs.Rect;\nvar objects = __webpack_require__(/*! ./utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\");\n\n/**\n * transform functions\n */\nvar matrix = __webpack_require__(/*! ./math/matrix */ \"./node_modules/gamejs/src/gamejs/math/matrix.js\");\nvar vectors = __webpack_require__(/*! ./math/vectors */ \"./node_modules/gamejs/src/gamejs/math/vectors.js\");\n\n/**\n * A Surface represents a bitmap image with a fixed width and height. The\n * most important feature of a Surface is that they can be `blitted`\n * onto each other.\n *\n * @example\n * new gamejs.graphics.Surface([width, height]);\n * new gamejs.graphics.Surface(width, height);\n * new gamejs.graphics.Surface(rect);\n * @constructor\n *\n * @param {Array} dimensions Array holding width and height\n */\nvar Surface = exports.Surface = function() {\n   var args = gamejs.normalizeRectArguments.apply(this, arguments);\n   var width = args.left;\n   var height = args.top;\n   // unless argument is rect:\n   if (arguments.length == 1 && arguments[0] instanceof Rect) {\n      width = args.width;\n      height = args.height;\n   }\n   // only for rotatation & scale\n   /** @ignore */\n   this._matrix = matrix.identity();\n   /** @ignore */\n    this._canvas = document.createElement(\"canvas\");\n    this._canvas.width = width;\n    this._canvas.height = height;\n    /** @ignore */\n    this._blitAlpha = 1.0;\n\n   /** @ignore */\n   this._context = this._canvas.getContext('2d');\n   // using exports is weird but avoids circular require\n   if (gamejs.display._isSmoothingEnabled()) {\n      this._smooth();\n   } else {\n      this._noSmooth();\n   }\n   return this;\n};\n\n/** @ignore */\nSurface.prototype._noSmooth = function() {\n    // disable image scaling\n    // see https://developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior\n    // and https://github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c\n    this.context.mozImageSmoothingEnabled = false;\n  this.context.webkitImageSmoothingEnabled = false;\n   return;\n};\n/** @ignore */\nSurface.prototype._smooth = function() {\n  this.context.mozImageSmoothingEnabled = true;\n  this.context.webkitImageSmoothingEnabled = true;\n\n};\n\n/**\n * Blits another Surface on this Surface. The destination where to blit to\n * can be given (or it defaults to the top left corner) as well as the\n * Area from the Surface which should be blitted (e.g., for cutting out parts of\n * a Surface).\n *\n * @example\n * // blit flower in top left corner of display\n * displaySurface.blit(flowerSurface);\n *\n * // position flower at 10/10 of display\n * displaySurface.blit(flowerSurface, [10, 10])\n *\n * // ... `dest` can also be a rect whose topleft position is taken:\n * displaySurface.blit(flowerSurface, new gamejs.Rect([10, 10]);\n *\n * // only blit half of the flower onto the display\n * var flowerRect = flowerSurface.rect;\n * flowerRect = new gamejs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])\n * displaySurface.blit(flowerSurface, [0,0], flowerRect);\n *\n * @param {gamejs.graphics.Surface} src The Surface which will be blitted onto this one\n * @param {gamejs.Rect|Array} dst the Destination x, y position in this Surface.\n *            If a Rect is given, it's top and left values are taken. If this argument\n *            is not supplied the blit happens at [0,0].\n * @param {gamesjs.Rect|Array} area the Area from the passed Surface which\n *            should be blitted onto this Surface.\n * @param {Number} compositionOperation how the source and target surfaces are composited together; one of: source-atop, source-in, source-out, source-over (default), destination-atop, destination-in, destination-out, destination-over, lighter, copy, xor; for an explanation of these values see: http://dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation\n * @returns {gamejs.Rect} Rect actually repainted FIXME actually return something?\n */\nSurface.prototype.blit = function(src, dest, area, compositeOperation) {\n\n   var rDest, rArea;\n\n   if (dest instanceof Rect) {\n      rDest = dest.clone();\n      var srcSize = src.getSize();\n      if (!rDest.width) {\n         rDest.width = srcSize[0];\n      }\n      if (!rDest.height) {\n         rDest.height = srcSize[1];\n      }\n    } else if (dest && dest instanceof Array && dest.length == 2) {\n      rDest = new Rect(dest, src.getSize());\n    } else {\n      rDest = new Rect([0,0], src.getSize());\n    }\n   compositeOperation = compositeOperation || 'source-over';\n\n   // area within src to be drawn\n   if (area instanceof Rect) {\n      rArea = area;\n   } else if (area && area instanceof Array && area.length == 2) {\n      var size = src.getSize();\n      rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);\n   } else {\n      rArea = new Rect([0,0], src.getSize());\n   }\n\n   if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {\n      throw new Error('[blit] bad parameters, destination is ' + rDest);\n   }\n\n   this.context.save();\n   this.context.globalCompositeOperation = compositeOperation;\n   this.context.globalAlpha = src._blitAlpha;\n   this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, rDest.left, rDest.top, rDest.width, rDest.height);\n   this.context.restore();\n   return;\n};\n\n/**\n * @returns {Number[]} the width and height of the Surface\n */\nSurface.prototype.getSize = function() {\n   return [this.canvas.width, this.canvas.height];\n};\n\n/**\n * Obsolte, only here for compatibility.\n * @deprecated\n * @ignore\n * @returns {gamejs.Rect} a Rect of the size of this Surface\n */\nSurface.prototype.getRect = function() {\n   return new Rect([0,0], this.getSize());\n};\n\n/**\n * Fills the whole Surface with a color. Usefull for erasing a Surface.\n * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'\n * @param {gamejs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)\n */\nSurface.prototype.fill = function(color, rect) {\n   this.context.save();\n   this.context.fillStyle = color || \"#000000\";\n   if (rect === undefined) {\n       rect = new Rect(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n   this.context.fillRect(rect.left, rect.top, rect.width, rect.height);\n   this.context.restore();\n   return;\n};\n\n/**\n * Clear the surface.\n */\nSurface.prototype.clear = function(rect) {\n   var size = this.getSize();\n   rect = rect || new Rect(0, 0, size[0], size[1]);\n   this.context.clearRect(rect.left, rect.top, rect.width, rect.height);\n   return;\n};\n\nobjects.accessors(Surface.prototype, {\n   /**\n    * @type gamejs.Rect\n    */\n   'rect': {\n      get: function() {\n         return this.getRect();\n      }\n   },\n   /**\n    * @ignore\n    */\n   'context': {\n      get: function() {\n         return this._context;\n      }\n   },\n   'canvas': {\n      get: function() {\n         return this._canvas;\n      }\n   }\n});\n\n/**\n * @returns {gamejs.graphics.Surface} a clone of this surface\n */\nSurface.prototype.clone = function() {\n  var newSurface = new Surface(this.getRect());\n  newSurface.blit(this);\n  return newSurface;\n};\n\n/**\n * @returns {Number} current alpha value\n */\nSurface.prototype.getAlpha = function() {\n   return (1 - this._blitAlpha);\n};\n\n/**\n * Set the alpha value for the whole Surface. When blitting the Surface on\n * a destination, the pixels will be drawn slightly transparent.\n * @param {Number} alpha value in range 0.0 - 1.0\n * @returns {Number} current alpha value\n */\nSurface.prototype.setAlpha = function(alpha) {\n   if (isNaN(alpha) || alpha < 0 || alpha > 1) {\n      return;\n   }\n\n   this._blitAlpha = (1 - alpha);\n   return (1 - this._blitAlpha);\n};\n\n/**\n * The data must be represented in left-to-right order, row by row top to bottom,\n * starting with the top left, with each pixel's red, green, blue, and alpha components\n * being given in that order for each pixel.\n * @see http://dev.w3.org/html5/2dcontext/#canvaspixelarray\n * @returns {ImageData} an object holding the pixel image data {data, width, height}\n */\nSurface.prototype.getImageData = function() {\n   var size = this.getSize();\n   return this.context.getImageData(0, 0, size[0], size[1]);\n};\n\n\n\n// FIXME all draw functions must return a minimal rect containing the drawn shape\n\n/**\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color valid #RGB string, e.g., \"#ff0000\"\n * @param {Array} startPos [x, y] position of line start\n * @param {Array} endPos [x, y] position of line end\n * @param {Number} width of the line, defaults to 1\n */\nexports.line = function(surface, color, startPos, endPos, width) {\n   var ctx = surface.context;\n   ctx.save();\n   ctx.beginPath();\n   ctx.strokeStyle = color;\n   ctx.lineWidth = width || 1;\n   ctx.moveTo(startPos[0], startPos[1]);\n   ctx.lineTo(endPos[0], endPos[1]);\n   ctx.stroke();\n   ctx.restore();\n   return;\n};\n\n/**\n * Draw connected lines. Use this instead of indiviudal line() calls for\n * better performance\n *\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color a valid #RGB string, \"#ff0000\"\n * @param {Boolean} closed if true the last and first point are connected\n * @param {Array} pointlist holding array [x,y] arrays of points\n * @param {Number} width width of the lines, defaults to 1\n */\nexports.lines = function(surface, color, closed, pointlist, width) {\n   closed = closed || false;\n   var ctx = surface.context;\n   ctx.save();\n   ctx.beginPath();\n   ctx.strokeStyle = ctx.fillStyle = color;\n   ctx.lineWidth = width || 1;\n   pointlist.forEach(function(point, idx) {\n      if (idx === 0) {\n         ctx.moveTo(point[0], point[1]);\n      } else {\n         ctx.lineTo(point[0], point[1]);\n      }\n   });\n   if (closed) {\n      ctx.lineTo(pointlist[0][0], pointlist[0][1]);\n   }\n   ctx.stroke();\n   ctx.restore();\n   return;\n};\n\n/**\n * Draw a circle on Surface\n *\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color a valid #RGB String, #ff00cc\n * @param {Array} pos [x, y] position of the circle center\n * @param {Number} radius of the circle\n * @param {Number} width width of the circle, if not given or 0 the circle is filled\n */\nexports.circle = function(surface, color, pos, radius, width) {\n   if (isNaN(radius)) {\n      throw new Error('[circle] radius required argument');\n   }\n   if (!pos || !(pos instanceof Array)) {\n      throw new Error('[circle] pos must be given & array' + pos);\n   }\n\n   var ctx = surface.context;\n   ctx.save();\n   ctx.beginPath();\n   ctx.strokeStyle = ctx.fillStyle = color;\n   ctx.lineWidth = width || 1;\n   ctx.arc(pos[0], pos[1], radius, 0, 2*Math.PI, true);\n   if (width === undefined || width === 0) {\n      ctx.fill();\n   } else {\n      ctx.stroke();\n   }\n   ctx.restore();\n   return;\n};\n\n/**\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color a valid #RGB String, #ff00cc\n * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used\n * @param {Number} width the width of line drawing the Rect, if 0 or not given the Rect is filled.\n */\nexports.rect = function(surface, color, rect, width) {\n   var ctx =surface.context;\n   ctx.save();\n   ctx.beginPath();\n   ctx.strokeStyle = ctx.fillStyle = color;\n   if (isNaN(width) || width === 0) {\n      ctx.fillRect(rect.left, rect.top, rect.width, rect.height);\n   } else {\n      ctx.lineWidth = width || 1;\n      ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);\n   }\n   ctx.restore();\n};\n\n/**\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color a valid #RGB String, #ff00cc\n * @param {Array} pos [x, y] position of the circle center\n * @param {Number} startAngle, both angles in radians\n * @param {Number} stopAngle\n * @param {Number} radius\n * @param {Number} width the width of line, if 0 or not given the arc is filled.\n */\nexports.arc= function(surface, color, pos, startAngle, stopAngle, radius, width) {\n   var ctx = surface.context;\n   ctx.save();\n   ctx.beginPath();\n   ctx.strokeStyle = ctx.fillStyle = color;\n   ctx.arc(pos[0], pos[1],\n            radius,\n            startAngle, stopAngle,\n            false\n         );\n   if (isNaN(width) || width === 0) {\n      ctx.fill();\n   } else {\n      ctx.lineWidth = width || 1;\n      ctx.stroke();\n   }\n   ctx.restore();\n};\n\n/**\n * Draw a polygon on the surface. The pointlist argument are the vertices\n * for the polygon.\n *\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color a valid #RGB String, #ff00cc\n * @param {Array} pointlist array of vertices [x, y] of the polygon\n * @param {Number} width the width of line, if 0 or not given the polygon is filled.\n */\nexports.polygon = function(surface, color, pointlist, width) {\n   var ctx = surface.context;\n   ctx.save();\n   ctx.fillStyle = ctx.strokeStyle = color;\n   ctx.beginPath();\n   pointlist.forEach(function(point, idx) {\n      if (idx === 0) {\n         ctx.moveTo(point[0], point[1]);\n      } else {\n         ctx.lineTo(point[0], point[1]);\n      }\n   });\n   ctx.closePath();\n   if (isNaN(width) || width === 0) {\n      ctx.fill();\n   } else {\n      ctx.lineWidth = width || 1;\n      ctx.stroke();\n   }\n   ctx.restore();\n};\n\n/**\n * Draw a quadratic curve with one control point on the surface.\n * The control point position defines the shape of the quadratic curve.\n *\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color valid #RGB string, e.g., \"#ff0000\"\n * @param {Array} startPos [x, y] the start position for the quadratic curve\n * @param {Array} endPos [x, y] the end position for the quadratic curve\n * @param {Array} controlPos [x, y] position of the control point\n * @param {Number} width of the quadratic curve, defaults to 1\n */\nexports.quadraticCurve = function(surface, color, startPos, endPos, controlPos, width) {\n   if (!startPos || !(startPos instanceof Array)) {\n      throw new Error('[quadratic_curve] startPos must be defined!');\n   }\n   if (!endPos || !(endPos instanceof Array)) {\n      throw new Error('[quadratic_curve] endPos must be defined!');\n   }\n   if (!controlPos || !(controlPos instanceof Array)) {\n      throw new Error('[quadratic_curve] controlPos must be defined!');\n   }\n\n   var ctx = surface.context;\n   ctx.save();\n   ctx.fillStyle = ctx.strokeStyle = color;\n   ctx.lineWidth = width || 1;\n\n   ctx.beginPath();\n   ctx.moveTo(startPos[0], startPos[1]);\n   ctx.quadraticCurveTo(controlPos[0], controlPos[1], endPos[0], endPos[1]);\n   ctx.stroke();\n\n   ctx.restore();\n};\n\n/**\n * Draw a bezier curve with two control points on the surface.\n * The control point positions define the shape of the bezier curve.\n *\n * @param {gamejs.graphics.Surface} surface the Surface to draw on\n * @param {String} color valid #RGB string, e.g., \"#ff0000\"\n * @param {Array} startPos [x, y] the start position for the bezier curve\n * @param {Array} endPos [x, y] the end position for the bezier curve\n * @param {Array} ct1Pos [x, y] position of the first control point\n * @param {Array} ct2Pos [x, y] position of the second control point\n * @param {Number} width of the bezier curve, defaults to 1\n */\nexports.bezierCurve = function(surface, color, startPos, endPos, ct1Pos, ct2Pos, width) {\n   if (!startPos || !(startPos instanceof Array)) {\n      throw new Error('[bezier_curve] startPos must be defined!');\n   }\n   if (!endPos || !(endPos instanceof Array)) {\n      throw new Error('[bezier_curve] endPos must be defined!');\n   }\n   if (!ct1Pos || !(ct1Pos instanceof Array)) {\n      throw new Error('[bezier_curve] ct1Pos must be defined!');\n   }\n   if (!ct2Pos || !(ct2Pos instanceof Array)) {\n      throw new Error('[bezier_curve] ct2Pos must be defined!');\n   }\n   var ctx = surface.context;\n   ctx.save();\n   ctx.fillStyle = ctx.strokeStyle = color;\n   ctx.lineWidth = width || 1;\n\n   ctx.beginPath();\n   ctx.moveTo(startPos[0], startPos[1]);\n   ctx.bezierCurveTo(ct1Pos[0], ct1Pos[1], ct2Pos[0], ct2Pos[1], endPos[0], endPos[1]);\n   ctx.stroke();\n\n   ctx.restore();\n};\n\n/**\n * Returns a new surface which holds this surface rotate by angle degrees.\n * Unless rotating by 90 degree increments, the image will be padded larger to hold the new size.\n * @param {angel} angle Clockwise angle by which to rotate\n * @returns {Surface} new, rotated surface\n */\nSurface.prototype.rotate = function (angle) {\n   var origSize = this.getSize();\n   var radians = (angle * Math.PI / 180);\n   var newSize = origSize;\n   // find new bounding box\n   if (angle % 360 !== 0) {\n      var rect = this.getRect();\n      var points = [\n         [-rect.width/2, rect.height/2],\n         [rect.width/2, rect.height/2],\n         [-rect.width/2, -rect.height/2],\n         [rect.width/2, -rect.height/2]\n      ];\n      var rotPoints = points.map(function(p) {\n         return vectors.rotate(p, radians);\n      });\n      var xs = rotPoints.map(function(p) { return p[0]; });\n      var ys = rotPoints.map(function(p) { return p[1]; });\n      var left = Math.min.apply(Math, xs);\n      var right = Math.max.apply(Math, xs);\n      var bottom = Math.min.apply(Math, ys);\n      var top = Math.max.apply(Math, ys);\n      newSize = [right-left, top-bottom];\n   }\n   var newSurface = new Surface(newSize);\n   var m = matrix.translate(this._matrix, origSize[0]/2, origSize[1]/2);\n   m = matrix.rotate(m, radians);\n   m = matrix.translate(m, -origSize[0]/2, -origSize[1]/2);\n   var offset = [(newSize[0] - origSize[0]) / 2, (newSize[1] - origSize[1]) / 2];\n   newSurface.context.save();\n   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n   newSurface.blit(this, offset);\n   newSurface.context.restore();\n   return newSurface;\n};\n\n/**\n * Returns a new surface holding the scaled surface.\n * @param {Array} dimensions new [width, height] of surface after scaling\n * @returns {Surface} new, scaled surface\n */\nSurface.prototype.scale = function(dims) {\n   var width = dims[0];\n   var height = dims[1];\n   if (width <= 0 || height <= 0) {\n      throw new Error('[gamejs.transform.scale] Invalid arguments for height and width', [width, height]);\n   }\n   var oldDims = this.getSize();\n   var ws = width / oldDims[0];\n   var hs = height / oldDims[1];\n   var newSurface = new Surface([width, height]);\n   var originalMatrix = this._matrix.slice(0);\n   var m = matrix.scale(matrix.identity(), [ws, hs]);\n   newSurface.context.save();\n   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n   newSurface.blit(this);\n   newSurface.context.restore();\n   return newSurface;\n};\n\n/**\n * Flip a Surface either vertically, horizontally or both. This returns\n * a new Surface (i.e: nondestructive).\n * @param {Boolean} flipHorizontal\n * @param {Boolean} flipVertical\n * @returns {Surface} new, flipped surface\n */\nSurface.prototype.flip = function(flipHorizontal, flipVertical) {\n   var dims = this.getSize();\n   var newSurface = new Surface(dims);\n   var scaleX = 1;\n   var scaleY = 1;\n   var xPos = 0;\n   var yPos = 0;\n   if (flipHorizontal === true) {\n      scaleX = -1;\n      xPos = -dims[0];\n   }\n   if (flipVertical === true) {\n      scaleY = -1;\n      yPos = -dims[1];\n   }\n   newSurface.context.save();\n   newSurface.context.scale(scaleX, scaleY);\n   newSurface.context.drawImage(this.canvas, xPos, yPos);\n   newSurface.context.restore();\n   return newSurface;\n};\n\n\n/**\n * Directly copy values from an array into a Surface.\n *\n * This is faster than blitting the `surface` property on a SurfaceArray\n *\n * The array must be the same dimensions as the Surface and will completely\n * replace all pixel values.\n * @param {gamejs.graphics.Surface} surface\n * @param {gamejs.graphics.Surfacearray.SurfaceArray} surfaceArray\n */\nexports.blitArray = function(surface, surfaceArray) {\n   surface.context.putImageData(surfaceArray.imageData, 0, 0);\n   return;\n};\n\n/**\n * Fast pixel access. The SurfaceArray can be constructed with a surface whose values\n * are then used to initialize the pixel array.\n *\n * The surface passed as argument is not modified by the SurfaceArray.\n *\n * If an array is used to construct SurfaceArray, the array must describe\n * the dimensions of the SurfaceArray [width, height].\n *\n * @example\n *\n *   // create array from display surface\n *   var srfArray = new SurfaceArray(display);\n *   // direct pixel access\n *   srfArray.set(50, 100, [255, 0, 0, 100]);\n *   console.log(srfArray.get(30, 50));\n *   // blit modified array back to display surface\n *   blitArray(display, srfArray);\n *\n * @param {gamejs.graphics.Surface|Array} surfaceOrDimensions\n * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation\n */\nvar SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {\n   var size = null;\n   var data = null;\n   var imageData = null;\n\n   /**\n    * Set rgba value at position x, y.\n    *\n    * For performance reasons this function has only one signature\n    * being Number, Number, Array[4].\n    *\n    * @param {Number} x x position of pixel\n    * @param {Number} y y position of pixel\n    * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)\n    * @throws Error if x, y out of range\n    */\n   this.set = function(x, y, rgba) {\n      var offset = (x * 4) + (y * size[0] * 4);\n      /** faster without\n      if (offset + 3 >= data.length || x < 0 || y < 0) {\n         throw new Error('x, y out of range', x, y);\n      }\n      **/\n      data[offset] = rgba[0];\n      data[offset+1] = rgba[1];\n      data[offset+2] = rgba[2];\n      data[offset+3] = rgba[3] === undefined ? 255 : rgba[3];\n      return;\n   };\n\n   /**\n    * Get rgba value at position xy,\n    * @param {Number} x\n    * @param {Number} y\n    * @returns {Array} [red, green, blue, alpha]\n    */\n   this.get = function(x, y) {\n      var offset = (x * 4) + (y * size[0] * 4);\n      return [\n         data[offset],\n         data[offset+1],\n         data[offset+2],\n         data[offset+3]\n      ];\n   };\n\n   /**\n    * a new gamejs.graphics.Surface on every access, representing\n    * the current state of the SurfaceArray.\n    * @type {gamejs.graphics.Surface}\n    */\n   // for jsdoc only\n   this.surface = null;\n\n   objects.accessors(this, {\n      surface: {\n         get: function() {\n            var s = new gamejs.graphics.Surface(size);\n            s.context.putImageData(imageData, 0, 0);\n            return s;\n         }\n      },\n      imageData: {\n         get: function() {\n            return imageData;\n         }\n      }\n   });\n\n   this.getSize = function() {\n      return size;\n   };\n\n   /**\n    * constructor\n    */\n   if (surfaceOrDimensions instanceof Array) {\n      size = surfaceOrDimensions;\n      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);\n      data = imageData.data;\n   } else {\n      size = surfaceOrDimensions.getSize();\n      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);\n      data = imageData.data;\n   }\n   return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/graphics.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/http.js":
/*!************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/http.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Make synchronous http requests to your game's serverside component.\n *\n * If you configure a ajax base URL you can make http requests to your\n * server using those functions.\n\n * The most high-level functions are `load()` and `save()` which take\n * and return a JavaScript object, which they will send to / recieve from\n * the server-side in JSON format.\n *\n *\n */\n\n/**\n * Response object returned by http functions `get` and `post`. This\n * class is not instantiable.\n *\n * @param{String} responseText\n * @param {String} responseXML\n * @param {Number} status\n * @param {String} statusText\n */\nexports.Response = function() {\n   /**\n    * @param {String} header\n    */\n   this.getResponseHeader = function(header)  {\n   };\n   throw new Error('response class not instantiable');\n};\n\n/**\n * Make http request to server-side\n * @param {String} method http method\n * @param {String} url\n * @param {String|Object} data\n * @param {String|Object} type \"Accept\" header value\n * @return {Response} response\n */\nvar ajax = exports.ajax = function(method, url, data, type) {\n   data = data || null;\n   var response = new XMLHttpRequest();\n   response.open(method, url, false);\n   if (type) {\n      response.setRequestHeader(\"Accept\", type);\n   }\n   if (data instanceof Object) {\n      data = JSON.stringify(data);\n      response.setRequestHeader('Content-Type', 'application/json');\n   }\n   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n   response.send(data);\n   return response;\n};\n\n/**\n * Make http GET request to server-side\n * @param {String} url\n */\nvar get = exports.get = function(url) {\n   return ajax('GET', url);\n};\n\n/**\n * Make http POST request to server-side\n * @param {String} url\n * @param {String|Object} data\n * @param {String|Object} type \"Accept\" header value\n * @returns {Response}\n */\nvar post = exports.post = function(url, data, type) {\n   return ajax('POST', url, data, type);\n};\n\nfunction stringify(response) {\n   /* jshint ignore:start */\n   return eval('(' + response.responseText + ')');\n   /* jshint ignore:end */\n}\n\nfunction ajaxBaseHref() {\n    return (window.$g && window.$g.ajaxBaseHref) || './';\n}\n\n/**\n * Load an object from the server-side.\n * @param {String} url\n * @return {Object} the object loaded from the server\n */\nexports.load = function(url) {\n   return stringify(get(ajaxBaseHref() + url));\n};\n\n/**\n * Send an object to a server-side function.\n * @param {String} url\n * @param {String|Object} data\n * @param {String|Object} type \"Accept\" header value\n * @returns {Object} the response object\n */\nexports.save = function(url, data, type) {\n   return stringify(post(ajaxBaseHref() + url, {payload: data}, type));\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/http.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/image.js":
/*!*************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/image.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\n\n/**\n * @fileoverview Load images as Surfaces.\n *\n * Sounds & Images are loaded relative to your game's html page\n * (the html which includes the GameJs code) or relative to the\n * property `window.$g.resourceBaseHref`\n * if it is set.\n *\n *\n */\n\nvar CACHE = {};\n\n/**\n * need to export preloading status for require\n * @ignore\n */\nvar _PRELOADING = false;\n\n/**\n * Load image and return it on a Surface.\n *\n * All images must be preloaded before they can be used.\n * @example\n\n *     gamejs.preload([\"./images/ship.png\", \"./images/sunflower.png\"]);\n *     // ...later...\n *     display.blit(gamejs.image.load('images/ship.png'))\n *\n * @param {String|dom.Image} uriOrImage resource uri for image\n * @returns {gamejs.graphics.Surface} surface with the image on it.\n */\nexports.load = function(key) {\n   var img;\n   if (typeof key === 'string') {\n      img = CACHE[key];\n      if (!img) {\n\t\t\tthrow new Error('Missing \"' + key + '\", gamejs.preload() all images before trying to load them.');\n      }\n   } else {\n      img = key;\n   }\n   var canvas = document.createElement('canvas');\n   // IEFIX missing html5 feature naturalWidth/Height\n   canvas.width = img.naturalWidth || img.width;\n   canvas.height = img.naturalHeight || img.height;\n   var context = canvas.getContext('2d');\n   context.drawImage(img, 0, 0);\n   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };\n   var surface = new gamejs.graphics.Surface(img.getSize());\n   // NOTE hack setting protected _canvas directly\n   surface._canvas = canvas;\n   surface._context = context;\n   return surface;\n};\n\n\n/**\n * add all images on the currrent page into cache\n * @ignore\n */\nexports.init = function() {\n   return;\n};\n\n/**\n * preload the given img URIs\n * @returns {Function} which returns 0-1 for preload progress\n * @ignore\n */\nexports.preload = function(imgIdents) {\n\n   var countLoaded = 0;\n   var countTotal = 0;\n\n   function incrementLoaded() {\n      countLoaded++;\n      if (countLoaded == countTotal) {\n         _PRELOADING = false;\n      }\n      if (countLoaded % 10 === 0) {\n         gamejs.logging.debug('gamejs.image: preloaded  ' + countLoaded + ' of ' + countTotal);\n      }\n   }\n\n   function getProgress() {\n      return countTotal > 0 ? countLoaded / countTotal : 1;\n   }\n\n   function successHandler() {\n      addToCache(this);\n      incrementLoaded();\n   }\n   function errorHandler() {\n      incrementLoaded();\n      throw new Error('Error loading ' + this.src);\n   }\n\n   var key;\n   for (key in imgIdents) {\n      var lowerKey = key.toLowerCase();\n      if (lowerKey.indexOf('.png') == -1 &&\n            lowerKey.indexOf('.jpg') == -1 &&\n            lowerKey.indexOf('.jpeg') == -1 &&\n            lowerKey.indexOf('.svg') == -1 &&\n            lowerKey.indexOf('.gif') == -1) {\n         continue;\n      }\n      var img = new Image();\n      img.addEventListener('load', successHandler, true);\n      img.addEventListener('error', errorHandler, true);\n      img.src = imgIdents[key];\n      img.gamejsKey = key;\n      countTotal++;\n   }\n   if (countTotal > 0) {\n      _PRELOADING = true;\n   }\n   return getProgress;\n};\n\n/**\n * add the given <img> dom elements into the cache.\n * @private\n */\nvar addToCache = function(img) {\n   CACHE[img.gamejsKey] = img;\n   return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/image.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/logging.js":
/*!***************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/logging.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * @fileoverview Static methods for logging and setting the log level. All logging functions (`info()`, `debug()`, etc.) take\n * any number of arguments and will print them in one line.\n *\n */\n\nvar DEBUG_LEVELS = ['debug', 'info', 'warn', 'error', 'fatal'];\nvar debugLevel = 2;\nvar gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\n\n/**\n * set logLevel as string or number\n *   * 0 = info\n *   * 1 = warn\n *   * 2 = error\n *   * 3 = fatal\n *\n * @example\n * gamejs.setLogLevel(0); // debug\n * gamejs.setLogLevel('error'); // equal to setLogLevel(2)\n */\nexports.setLogLevel = function(logLevel) {\n   if (typeof logLevel === 'string' && DEBUG_LEVELS.indexOf(logLevel)) {\n      debugLevel = DEBUG_LEVELS.indexOf(logLevel);\n   } else if (typeof logLevel === 'number') {\n      debugLevel = logLevel;\n   } else {\n      throw new Error('invalid logLevel ', logLevel, ' Must be one of: ', DEBUG_LEVELS);\n   }\n   return debugLevel;\n};\n\n/**\n * Log a msg to the console if console is enable\n * @param {String} message,... the msg to log\n */\nvar log = exports.log = function() {\n\n   if (gamejs.thread.inWorker === true) {\n      gamejs.thread._logMessage.apply(null, arguments);\n      return;\n   }\n\n   // IEFIX can't call apply on console\n   var args = Array.prototype.slice.apply(arguments, [0]);\n   args.unshift(Date.now());\n   if (window.console !== undefined && console.log.apply) {\n      console.log.apply(console, args);\n   }\n};\n/**\n * @param {String} message,... to log\n */\nexports.debug = function() {\n   if (debugLevel <= DEBUG_LEVELS.indexOf('debug')) {\n      log.apply(this, arguments);\n   }\n};\n/**\n * @param {String} message,... to log\n */\nexports.info = function() {\n   if (debugLevel <= DEBUG_LEVELS.indexOf('info')) {\n      log.apply(this, arguments);\n   }\n};\n/**\n * @param {String} message,... to log\n */\nexports.warn = function() {\n   if (debugLevel <= DEBUG_LEVELS.indexOf('warn')) {\n      log.apply(this, arguments);\n   }\n};\n/**\n * @param {String} message,... to log\n */\nexports.error = function() {\n   if (debugLevel <= DEBUG_LEVELS.indexOf('error')) {\n      log.apply(this, arguments);\n   }\n};\n/**\n * @param {String} message to log\n */\nexports.fatal = function() {\n   if (debugLevel <= DEBUG_LEVELS.indexOf('fatal')) {\n      log.apply(this, arguments);\n   }\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/logging.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/angles.js":
/*!*******************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/angles.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Degrees and radians.\n *\n */\n\n/**\n *\n * absolute angle to relative angle, in degrees\n * @param {Number} absolute angle in degrees\n * @returns {Number} relative angle in degrees\n */\nexports.normaliseDegrees=function(degrees){\n    degrees=degrees % 360;\n    if(degrees<0) {\n        degrees+=360;\n    }\n    return degrees;\n};\n\n/**\n *\n * absolute angle to relative angle, in radians\n * @param {Number} absolute angle in radians\n * @returns {Number} relative angle in radians\n */\nexports.normaliseRadians=function(radians){\n    radians=radians % (2*Math.PI);\n    if(radians<0) {\n        radians+=(2*Math.PI);\n    }\n    return radians;\n};\n\n/**\n *\n * convert radians to degrees\n * @param {Number} radians\n * @returns {Number} degrees\n */\nexports.degrees=function(radians) {\n    return radians*(180/Math.PI);\n};\n\n/**\n *\n * convert degrees to radians\n * @param {Number} degrees\n * @returns {Number} radians\n */\nexports.radians=function(degrees) {\n    return degrees*(Math.PI/180);\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/angles.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/binaryheap.js":
/*!***********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/binaryheap.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Binary Heap implementation from Eloquent JavaScript\n *\n * @see http://eloquentjavascript.net/appendix2.html\n */\nvar BinaryHeap = exports.BinaryHeap = function(scoreFunction){\n   /**\n    * @ignore\n    */\n   this.content = [];\n   /**\n    * @ignore\n    */\n   this.scoreFunction = scoreFunction;\n   return this;\n};\n\n/**\n * Add element to heap.\n * @param {Object} element\n */\nBinaryHeap.prototype.push = function(element) {\n   this.content.push(element);\n   this.sinkDown(this.content.length - 1);\n   return;\n};\n\n/**\n * Return first element from heap.\n * @param {Object} element\n * @returns {Object} element\n */\nBinaryHeap.prototype.pop = function() {\n   // Store the first element so we can return it later.\n   var result = this.content[0];\n   // Get the element at the end of the array.\n   var end = this.content.pop();\n   // If there are any elements left, put the end element at the\n   // start, and let it bubble up.\n   if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n   }\n   return result;\n};\n\n/**\n * Remove the given element from the heap.\n * @param {Object} element\n * @throws {Error} if node not found\n * @returns true if the node was round and removed or fals otherwise\n */\nBinaryHeap.prototype.remove = function(node) {\n   // To remove a value, we must search through the array to find\n   // it.\n   var isFound = this.content.some(function(cNode, idx) {\n      if (cNode == node) {\n         var end = this.content.pop();\n         if (idx != this.content.length) {\n            this.content[idx] = end;\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n               this.sinkDown(idx);\n            } else {\n               this.bubbleUp(idx);\n            }\n         }\n         return true;\n      }\n      return false;\n   }, this);\n   return isFound;\n};\n\n/**\n * Number of elements in heap.\n */\nBinaryHeap.prototype.size = function() {\n   return this.content.length;\n};\n\n/**\n * @ignore\n */\nBinaryHeap.prototype.sinkDown = function(idx) {\n   // Fetch the element that has to be sunk\n   var element = this.content[idx];\n   // When at 0, an element can not sink any further.\n   while (idx > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentIdx = Math.floor((idx + 1) / 2) - 1;\n      var parent = this.content[parentIdx];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n         this.content[parentIdx] = element;\n         this.content[idx] = parent;\n         // Update 'n' to continue at the new position.\n         idx = parentIdx;\n      // Found a parent that is less, no need to sink any further.\n      } else {\n         break;\n      }\n   }\n   return;\n};\n\n/**\n * @ignore\n */\nBinaryHeap.prototype.bubbleUp = function(idx) {\n   // Look up the target element and its score.\n   var length = this.content.length;\n   var element = this.content[idx];\n   var elemScore = this.scoreFunction(element);\n\n   while(true) {\n      // Compute the indices of the child elements.\n      var child2Idx = (idx + 1) * 2;\n      var child1Idx= child2Idx - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swapIdx = null;\n      // If the first child exists (is inside the array)...\n      var child1Score;\n      if (child1Idx < length) {\n         // Look it up and compute its score.\n         var child1 = this.content[child1Idx];\n         child1Score = this.scoreFunction(child1);\n         // If the score is less than our element's, we need to swap.\n         if (child1Score < elemScore) {\n            swapIdx = child1Idx;\n         }\n      }\n      // Do the same checks for the other child.\n      if (child2Idx < length) {\n         var child2 = this.content[child2Idx];\n         var child2Score = this.scoreFunction(child2);\n         if (child2Score < (swapIdx === null ? elemScore : child1Score)) {\n            swapIdx = child2Idx;\n         }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swapIdx !== null) {\n         this.content[idx] = this.content[swapIdx];\n         this.content[swapIdx] = element;\n         idx = swapIdx;\n      // Otherwise, we are done.\n      } else {\n         break;\n      }\n   }\n   return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/binaryheap.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/matrix.js":
/*!*******************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/matrix.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Matrix manipulation, used by GameJs itself. You\n * probably do not need this unless you manipulate a Context's transformation\n * matrix yourself.\n */\n\n// correct way to do scale, rotate, translate\n// *  gamejs.utils.matrix will be used in gamejs.transforms, modifing the surfaces.matrix\n// * this matrix must be applied to the context in Surface.draw()\n\n/**\n * @returns {Array} [1, 0, 0, 1, 0, 0]\n */\nvar identiy = exports.identity = function () {\n   return [1, 0, 0, 1, 0, 0];\n};\n\n/**\n * @param {Array} matrix\n * @param {Array} matrix\n * @returns {Array} matrix sum\n */\nvar add = exports.add = function(m1, m2) {\n   return [\n      m1[0] + m2[0],\n      m1[1] + m2[1],\n      m1[2] + m2[2],\n      m1[3] + m2[3],\n      m1[4] + m2[4],\n      m1[5] + m2[5],\n      m1[6] + m2[6]\n   ];\n};\n\n/**\n * @param {Array} matrix A\n * @param {Array} matrix B\n * @returns {Array} matrix product\n */\nvar multiply = exports.multiply = function(m1, m2) {\n   return [\n      m1[0] * m2[0] + m1[2] * m2[1],\n      m1[1] * m2[0] + m1[3] * m2[1],\n      m1[0] * m2[2] + m1[2] * m2[3],\n      m1[1] * m2[2] + m1[3] * m2[3],\n      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n   ];\n};\n\n/**\n * @param {Array} matrix\n * @param {Number} dx\n * @param {Number} dy\n * @returns {Array} translated matrix\n */\nvar translate = exports.translate = function(m1, dx, dy) {\n   return multiply(m1, [1, 0, 0, 1, dx, dy]);\n};\n\n/**\n * @param {Array} matrix\n * @param {Number} angle in radians\n * @returns {Array} rotated matrix\n */\nvar rotate = exports.rotate = function(m1, angle) {\n   // radians\n   var sin = Math.sin(angle);\n   var cos = Math.cos(angle);\n   return multiply(m1, [cos, sin, -sin, cos, 0, 0]);\n};\n\n/**\n * @param {Array} matrix\n * @returns {Number} rotation in radians\n */\nvar rotation = exports.rotation = function(m1) {\n      return Math.atan2(m1[1], m1[0]);\n};\n\n/**\n * @param {Array} matrix\n * @param {Array} vector [a, b]\n * @returns {Array} scaled matrix\n */\nvar scale = exports.scale = function(m1, svec) {\n   var sx = svec[0];\n   var sy = svec[1];\n   return multiply(m1, [sx, 0, 0, sy, 0, 0]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/matrix.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/noise.js":
/*!******************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/noise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview\n * A noise generator comparable to Perlin noise, which is useful\n * for generating procedural content.\n *\n * This implementation provides 2D and 3D noise:\n *\n *    var simplex = new Simplex();\n *    simplex.get(2, 4);\n *    simple.get3d(1, 2, 4);\n *\n * You can optionally\n * pass a seedable pseudo-random number generator to its constructor. This\n * generator object is assumed to have a `random()` method; `Math` is used\n * per default:\n *\n *     var Alea = require('gamejs/math/random').Alea;\n *     var simplex = new Simplex(new Alea());\n *\n * Also see `gamejs/math/random` for a seedable pseudo random number generator\n *\n * @see gamejs/utils/prng\n */\n\n// Ported to JS by by zz85 <https://github.com/zz85> from Stefan\n// Gustavson's java implementation\n// <http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf>\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n\n/**\n * @param {Object} randomNumberGenerator the random number generator to use; most provide `random()` method\n * @usage\n *  var simplex = new gamejs.noise.Simplex();\n *  simplex.get(x, y);\n *  // or for 3d noise\n *  simple.get(x, y, y);\n */\n\nvar Simplex = exports.Simplex = function(r) {\n  if (r === undefined) {\n    r = Math;\n  }\n  /** @ignore */\n  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],\n               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],\n               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];\n  /** @ignore */\n  this.p = [];\n  var i;\n  for (i=0; i<256; i++) {\n   this.p[i] = Math.floor(r.random()*256);\n  }\n  // To remove the need for index wrapping, double the permutation table length\n  /** @ignore */\n  this.perm = [];\n  for(i=0; i<512; i++) {\n    this.perm[i]=this.p[i & 255];\n  }\n\n  // A lookup table to traverse the simplex around a given point in 4D.\n  // Details can be found where this table is used, in the 4D noise method.\n  /** @ignore */\n  this.simplex = [\n    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],\n    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],\n    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],\n    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],\n    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],\n    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];\n};\n\n/** @ignore */\nSimplex.prototype.dot = function(g, x, y) {\n   return g[0]*x + g[1]*y;\n};\n\n/**\n * @param {Number} x\n * @param {Number} y\n * @returns {Number} noise for given position, in range [-1, 1]\n */\nSimplex.prototype.get = function(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  var F2 = 0.5*(Math.sqrt(3.0)-1.0);\n  var s = (xin+yin)*F2; // Hairy factor for 2D\n  var i = Math.floor(xin+s);\n  var j = Math.floor(yin+s);\n  var G2 = (3.0-Math.sqrt(3.0))/6.0;\n  var t = (i+j)*G2;\n  var X0 = i-t; // Unskew the cell origin back to (x,y) space\n  var Y0 = j-t;\n  var x0 = xin-X0; // The x,y distances from the cell origin\n  var y0 = yin-Y0;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n  var y2 = y0 - 1.0 + 2.0 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  var ii = i & 255;\n  var jj = j & 255;\n  var gi0 = this.perm[ii+this.perm[jj]] % 12;\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;\n  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;\n  // Calculate the contribution from the three corners\n  var t0 = 0.5 - x0*x0-y0*y0;\n  if(t0<0) {\n    n0 = 0.0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n  var t1 = 0.5 - x1*x1-y1*y1;\n  if(t1<0) {\n    n1 = 0.0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n  }\n  var t2 = 0.5 - x2*x2-y2*y2;\n  if(t2<0) {\n    n2 = 0.0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70.0 * (n0 + n1 + n2);\n};\n\n\n/**\n * @param {Number} x\n * @param {Number} y\n * @param {Number} y\n * @returns {Number} noise for given position, in range [-1, 1]\n */\nSimplex.prototype.get3d = function(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n  var F3 = 1.0/3.0;\n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n  var i = Math.floor(xin+s);\n  var j = Math.floor(yin+s);\n  var k = Math.floor(zin+s);\n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n  var t = (i+j+k)*G3;\n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n  var Y0 = j-t;\n  var Z0 = k-t;\n  var x0 = xin-X0; // The x,y,z distances from the cell origin\n  var y0 = yin-Y0;\n  var z0 = zin-Z0;\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n  if(x0>=y0) {\n    if(y0>=z0)\n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n    }\n  else { // x0<y0\n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n  }\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n  var y2 = y0 - j2 + 2.0*G3;\n  var z2 = z0 - k2 + 2.0*G3;\n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n  var y3 = y0 - 1.0 + 3.0*G3;\n  var z3 = z0 - 1.0 + 3.0*G3;\n  // Work out the hashed gradient indices of the four simplex corners\n  var ii = i & 255;\n  var jj = j & 255;\n  var kk = k & 255;\n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;\n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;\n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;\n  // Calculate the contribution from the four corners\n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n  if(t0<0) {\n    n0 = 0.0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);\n  }\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n  if(t1<0) {\n    n1 = 0.0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);\n  }\n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n  if(t2<0) {\n    n2 = 0.0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);\n  }\n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n  if(t3<0) {\n    n3 = 0.0;\n  } else {\n    t3 *= t3;\n    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to stay just inside [-1,1]\n  return 32.0*(n0 + n1 + n2 + n3);\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/noise.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/random.js":
/*!*******************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/random.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview A seedable random-number generator.\n *\n * A generator is initialized by GameJs and can be used with the\n * static functions of this module:\n *\n *    gamejs.random.choose([1,2,4]);\n *    // integet between and including 2 and 5\n *    gamejs.random.integer(2, 5);\n *\n * You can re-initialize this generator with a different seed by\n * calling `gamejs.utils.prng.init(seed)` after which the static\n * functions in this module will use the new seed.\n *\n * @usage\n *  var prng = require('gamejs/math/random');\n *  prng.random(); // 0.6765871671959758\n *  prng.integer(2, 10); // 5\n *  prng.choose([1,2,3,4,5]); // 3\n */\n// From http://baagoe.com/en/RandomMusings/javascript/\n// Johannes Baage <baagoe@baagoe.com>, 2010\n// API modified by Simon Oberhammer <simon@nekapuzer.at>, 2012\n// discussion of the used algorithms <http://baagoe.org/en/w/index.php/Better_random_numbers_for_javascript>\n\n\n/** @ignore **/\nvar Mash = function Mash() {\n  var n = 0xefc8249d;\n  this.hash = function(data) {\n    data = data.toString();\n    var i;\n    for (i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n\n  this.version = 'Mash 0.9';\n  return this;\n};\n\n/**\n * A seedable pseudo-random number generator.\n * @param {Number|String} seed the seed for generating the numbers\n *\n * @usage\n *  var prng = require('gamejs/math/random');\n *  var seed = 'gamejs';\n *  var alea = new prng.Alea(seed);\n *  alea.random(); // 0.6765871671959758\n *  alea.random(); // 0.15881546027958393\n *\n *  // generator with the same seed will generate the same sequence\n *  // of numbers:\n *  var aleaTwo = new prng.Alea(seed);\n *  aleaTwo.random(); // 0.6765871671959758\n *  aleaTwo.random(); // 0.15881546027958393\n */\nvar Alea = exports.Alea = function Alea() {\n   var args = Array.prototype.slice.call(arguments);\n   var s0 = 0;\n   var s1 = 0;\n   var s2 = 0;\n   var c = 1;\n   if (args.length === 0 || !args[0]) {\n     args = [Date.now()];\n   }\n   var mash = new Mash();\n   s0 = mash.hash(' ');\n   s1 = mash.hash(' ');\n   s2 = mash.hash(' ');\n\n   var i;\n   for (i = 0; i < args.length; i++) {\n     s0 -= mash.hash(args[i]);\n     if (s0 < 0) {\n       s0 += 1;\n     }\n     s1 -= mash.hash(args[i]);\n     if (s1 < 0) {\n       s1 += 1;\n     }\n     s2 -= mash.hash(args[i]);\n     if (s2 < 0) {\n       s2 += 1;\n     }\n   }\n   mash = null;\n\n   /**\n    * @returns {Number} the next random number as determined by the seed\n    */\n   this.random = function() {\n     var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n     s0 = s1;\n     s1 = s2;\n     s2 = t - (c = t | 0);\n     return s2;\n   };\n   this.integer = function(min, max) {\n     return min + parseInt(this.random() * (max-min+1), 10);\n   };\n   this.vector = function(min, max) {\n      return [this.integer(min[0], max[0]), this.integer(min[1], max[1])];\n   };\n   this.choose = function(items) {\n      return items[this.integer(0, items.length-1)];\n   };\n   return this;\n};\n\n// alea instance per gamejs instance\nvar alea = null;\n\n/**\n * @param {Number} min\n * @param {Number} max\n * @returns {Number} random integer between min and max\n */\nvar integer = exports.integer = function(min, max){\n    return alea.integer(min, max);\n};\n\n/**\n * @param {Array} minVector 2 integers, the minimum vector\n * @param {Array} maxVector 2 integers, the maximum vector\n * @returns {Array} a random vector [min[0]<=x<=max[0], min[1]<=y<=max[1]]\n */\nexports.vector = function(min, max){\n    return alea.vector(min, max);\n};\n\n/**\n * @param {Array} items\n * @returns {Object} random item from items list\n */\nexports.choose = function(items){\n    return alea.choose(items);\n};\n\n/**\n * @returns {Number} next random float between 0 and 1\n */\nexports.random = function() {\n  return alea.random();\n};\n\n/**\n * Re-initialize the per instance random number generator used\n * in the static functions on this module (e.g. vector())\n * @param {Number|String} seed\n */\nexports.init = function(seed) {\n  alea = new Alea(seed);\n};\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/random.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/math/vectors.js":
/*!********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/math/vectors.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Vector operations.\n\n */\nvar angles = __webpack_require__(/*! ./angles */ \"./node_modules/gamejs/src/gamejs/math/angles.js\");\n\n/**\n * @param {Array} origin point [b0, b1]\n * @param {Array} target point [b0, b1]\n * @returns {Number} distance between two points\n */\nexports.distance = function(a, b) {\n   return len(subtract(a, b));\n};\n\n/**\n * subtracts vectors [a0, a1] - [a0, a1]\n * @param {Array} a\n * @param {Array} b\n * @returns {Array} vector\n */\nvar subtract = exports.subtract = function(a, b) {\n   return [a[0] - b[0], a[1] - b[1]];\n};\n\n/**\n * adds vectors [a0, a1] - [a0, a1]\n * @param {Array} a vector\n * @param {Array} b vector\n * @returns {Array} vector\n */\nvar add = exports.add = function(a, b) {\n   return [a[0] + b[0], a[1] + b[1]];\n};\n\n/**\n * multiply vector with scalar or other vector\n * @param {Array} vector [v0, v1]\n * @param {Number|Array} vector or number\n * @returns {Number|Array} result\n */\nvar multiply = exports.multiply = function(a, s) {\n   if (typeof s === 'number') {\n      return [a[0] * s, a[1] * s];\n   }\n\n   return [a[0] * s[0], a[1] * s[1]];\n};\n\n/**\n * @param {Array} a vector\n * @param {Number} s\n */\nexports.divide = function(a, s) {\n   if (typeof s === 'number') {\n      return [a[0] / s, a[1] / s];\n   }\n   throw new Error('only divide by scalar supported');\n};\n\n/**\n * @param {Array} vector [v0, v1]\n * @returns {Number} length of vector\n */\nvar len = exports.len = function(v) {\n   return Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n};\n\n/**\n *\n * normalize vector to unit vector\n * @param {Array} vector [v0, v1]\n * @returns {Array} unit vector [v0, v1]\n */\nvar unit = exports.unit = function(v) {\n   var l = len(v);\n   if(l) {\n      return [v[0] / l, v[1] / l];\n   }\n   return [0, 0];\n};\n\n/**\n *\n * rotate vector\n * @param {Array} vector [v0, v1]\n * @param {Number} angle to rotate vector by, radians. can be negative\n * @returns {Array} rotated vector [v0, v1]\n */\nexports.rotate=function(v, angle){\n   angle=angles.normaliseRadians(angle);\n   return [v[0]* Math.cos(angle)-v[1]*Math.sin(angle),\n           v[0]* Math.sin(angle)+v[1]*Math.cos(angle)];\n\n};\n\n/**\n *\n * calculate vector dot product\n * @param {Array} vector [v0, v1]\n * @param {Array} vector [v0, v1]\n * @returns {Number} dot product of v1 and v2\n */\nvar dot = exports.dot=function(v1, v2){\n   return (v1[0] * v2[0]) + (v1[1] * v2[1]);\n};\n\n/**\n *\n * calculate angle between vectors\n * @param {Array} vector [v0, v1]\n * @param {Array} vector [v0, v1]\n * @returns {Number} angle between v1 and v2 in radians\n */\nexports.angle=function(v1, v2){\n   var perpDot = v1[0] * v2[1] - v1[1] * v2[0];\n   return Math.atan2(perpDot, dot(v1,v2));\n};\n\n/**\n * @returns {Array} vector with max length as specified.\n */\nexports.truncate = function(v, maxLength) {\n   if (len(v) > maxLength) {\n      return multiply(unit(v), maxLength);\n   }\n   return v;\n};\n\n\n/**\n * @returns the center of multipled 2d points\n * @param {Array} first point\n * @param {Array} second point\n * @param {Array} ...\n */\nexports.centroid = function() {\n   var args = Array.prototype.slice.apply(arguments, [0]);\n   var c = [0,0];\n   args.forEach(function(p) {\n      c[0] += parseInt(p[0], 10);\n      c[1] += parseInt(p[1], 10);\n   });\n   var len = args.length;\n   return [\n      c[0] / len,\n      c[1] / len\n   ];\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/math/vectors.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/pathfinding.js":
/*!*******************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/pathfinding.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview\n * A* path finding algorithm\n *\n * Use the `findRoute(map, from, to, [timeout])` function to get the linked list\n * leading `from` a point `to` another on the given `map`.\n *\n * The map must implement the interface `gamejs.pathfinding.Map`. This\n * class already holds an example implementation for debugging use.\n *\n * Optionally, the search is cancelled after `timeout` in millseconds.\n *\n * If there is no route `null` is returned.\n *\n * @see http://en.wikipedia.org/wiki/A*_search_algorithm\n * @see http://eloquentjavascript.net/chapter7.html\n */\nvar BinaryHeap = __webpack_require__(/*! ./math/binaryheap */ \"./node_modules/gamejs/src/gamejs/math/binaryheap.js\").BinaryHeap;\n\n/**\n * helper function for A*\n */\nfunction ReachedList(hashFn) {\n   var list = {};\n\n   this.store = function(point, route) {\n      list[hashFn(point)] = route;\n      return;\n   };\n\n   this.find = function(point) {\n      return list[hashFn(point)];\n   };\n   return this;\n}\n\n\n/** A* search function.\n *\n * This function expects a `Map` implementation and the origin and destination\n * points given. If there is a path between the two it will return the optimal\n * path as a linked list. If there is no path it will return null.\n *\n * The linked list is in reverse order: the first item is the destination and\n * the path to the origin follows.\n *\n * @param {Map} map map instance, must follow interface defined in {Map}\n * @param {Array} origin\n * @param {Array} destination\n * @param {Number} timeout milliseconds after which search should be canceled\n * @returns {Object} the linked list leading from `to` to `from` (sic!).\n **/\nexports.findRoute = function(map, from, to, timeout) {\n   var open = new BinaryHeap(routeScore);\n   var hashFn = typeof map.hash === 'function' ? map.hash : defaultHash;\n   var reached = new ReachedList(hashFn);\n\n   function routeScore(route) {\n      if (route.score === undefined) {\n         route.score = map.estimatedDistance(route.point, to) + route.length;\n      }\n      return route.score;\n   }\n   function addOpenRoute(route) {\n      open.push(route);\n      reached.store(route.point, route);\n   }\n\n   function processNewPoints(direction) {\n      var known = reached.find(direction);\n      var newLength = route.length + map.actualDistance(route.point, direction);\n      if (!known || known.length > newLength){\n         if (known) {\n            open.remove(known);\n         }\n         addOpenRoute({\n            point: direction,\n            from: route,\n            length: newLength\n         });\n      }\n   }\n   var startMs = Date.now();\n   var route = null;\n   addOpenRoute({\n      point: from,\n      from: null,\n      length: 0\n   });\n   var equalsFn = typeof map.equals === 'function' ? map.equals : defaultEquals;\n   while (open.size() > 0 && (!timeout || Date.now() - startMs < timeout)) {\n      route = open.pop();\n      if (equalsFn(to, route.point)) {\n         return route;\n      }\n      map.adjacent(route.point).forEach(processNewPoints);\n   } // end while\n   return null;\n};\n\nvar defaultEquals = function(a, b) {\n   return a[0] === b[0] && a[1] === b[1];\n};\n\nvar defaultHash = function(a) {\n   return a[0] + '-' + a[1];\n};\n\n/**\n * This is the interface for a Map that can be passed to the `findRoute()`\n * function. `Map` is not instantiable - see the unit tests for an example\n * implementation of Map.\n */\nvar Map = exports.Map = function() {\n   throw new Error('not instantiable, this is an interface');\n};\n\n/**\n * @param {Array} origin\n * @returns {Array} list of points accessible from given Point\n */\nMap.prototype.adjacent = function(origin) {\n};\n\n/**\n * @param {Object} a one of the points ot test for equality\n * @param {Object} b ... the other point\n * @returns Wheter the two points are equal.\n */\nMap.prototype.equals = defaultEquals;\n\n/**\n * @param {Object} a point\n * @returns {String} hash for the point\n */\nMap.prototype.hash = defaultHash;\n\n/**\n * Estimated lower bound distance between two points.\n * @param {Object} pointA\n * @param {Object} pointB\n * @returns {Number} the estimated distance between two points\n */\nMap.prototype.estimatedDistance = function(pointA, pointB) {\n   return 1;\n};\n\n/**\n * Actual distance between two points.\n * @param {Object} pointA\n * @param {Object} pointB\n * @returns {Number} the actual distance between two points\n */\nMap.prototype.actualDistance = function(pointA, pointB) {\n   return 1;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/pathfinding.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/pixelcollision.js":
/*!**********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/pixelcollision.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar objects = __webpack_require__(/*! ./utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\");\n\n/**\n * @fileoverview Image mask. Usefull for pixel perfect collision detection:\n *\n * @example\n * var unitMask = new Maks(unitSurface, collisionThresholdAlphaValue);\n * var spearMask = new Maks(unitSurface, collisionThresholdAlphaValue);\n * var collide = unitMask.overlap(spearMask);\n */\n\n\n/**\n * Creates an image mask from the given Surface. The alpha of each pixel is checked\n * to see if it is greater than the given threshold. If it is greater then\n * that pixel is set as not colliding.\n *\n * @param {Surface} surface used for image mask\n * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent\n *\n */\nvar Mask = exports.Mask = function(surface, threshold) {\n   /**\n    * @ignore\n    */\n   this._bits = [];\n\n   threshold = (threshold && (255 - threshold)) || 255;\n   var imgData = surface.getImageData().data;\n   var dims = surface.getSize();\n   /**\n    * @ignore\n    */\n   this.width = dims[0];\n   /**\n    * @ignore\n    */\n   this.height = dims[1];\n\n   var i,j;\n   for (i=0;i<this.width;i++) {\n      this._bits[i] = [];\n      for (j=0;j<this.height;j++) {\n         this._bits[i][j] = false;\n      }\n   }\n   for (i=0;i<imgData.length;i += 4) {\n      // y: pixel # / width\n      var y = parseInt((i / 4) / dims[0], 10);\n      // x: pixel # % width\n      var x = parseInt((i / 4) % dims[0], 10);\n      var alpha = imgData[i+3];\n      if (alpha >= threshold) {\n         this.setAt(x, y);\n      }\n   }\n   return;\n};\n\n/**\n * @param {gamejs.mask.Mask} otherMask\n * @param {Array} offset [x,y]\n * @returns the overlapping rectangle or null if there is no overlap;\n */\nMask.prototype.overlapRect = function(otherMask, offset) {\n   var arect = this.rect;\n   var brect = otherMask.rect;\n   if (offset) {\n      brect.moveIp(offset);\n   }\n   // bounding box intersect\n   if (!brect.collideRect(arect)) {\n      return null;\n   }\n   var xStart = Math.max(arect.left, brect.left);\n   var xEnd = Math.min(arect.right, brect.right);\n\n   var yStart = Math.max(arect.top, brect.top);\n   var yEnd = Math.min(arect.bottom, brect.bottom);\n\n   return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);\n};\n\n/**\n *\n * @returns True if the otherMask overlaps with this map.\n * @param {Mask} otherMask\n * @param {Array} offset\n */\nMask.prototype.overlap = function(otherMask, offset) {\n   var overlapRect = this.overlapRect(otherMask, offset);\n   if (overlapRect === null) {\n      return false;\n   }\n\n   var arect = this.rect;\n   var brect = otherMask.rect;\n   if (offset) {\n      brect.moveIp(offset);\n   }\n\n   var count = 0;\n   var x,y;\n   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {\n      for (x=overlapRect.left; x<=overlapRect.right; x++) {\n         if (this.getAt(x - arect.left, y - arect.top) &&\n             otherMask.getAt(x - brect.left, y - brect.top)) {\n             return true;\n         }\n      }\n   }\n   // NOTE this should not happen because either we bailed out\n   // long ago because the rects do not overlap or there is an\n   // overlap and we should not have gotten this far.\n   // throw new Error(\"Maks.overlap: overlap detected but could not create mask for it.\");\n   return false;\n};\n\n/**\n * @param {gamejs.mask.Mask} otherMask\n * @param {Array} offset [x,y]\n * @returns the number of overlapping pixels\n */\nMask.prototype.overlapArea = function(otherMask, offset) {\n   var overlapRect = this.overlapRect(otherMask, offset);\n   if (overlapRect === null) {\n      return 0;\n   }\n\n   var arect = this.rect;\n   var brect = otherMask.rect;\n   if (offset) {\n      brect.moveIp(offset);\n   }\n\n   var count = 0;\n   var x,y;\n   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {\n      for (x=overlapRect.left; x<=overlapRect.right; x++) {\n         if (this.getAt(x - arect.left, y - arect.top) &&\n             otherMask.getAt(x - brect.left, y - brect.top)) {\n             count++;\n         }\n      }\n   }\n   return count;\n};\n\n/**\n * @param {gamejs.mask.Mask} otherMask\n * @param {Array} offset [x,y]\n * @returns a mask of the overlapping pixels\n */\nMask.prototype.overlapMask = function(otherMask, offset) {\n   var overlapRect = this.overlapRect(otherMask, offset);\n   if (overlapRect === null) {\n      return 0;\n   }\n\n   var arect = this.rect;\n   var brect = otherMask.rect;\n   if (offset) {\n      brect.moveIp(offset);\n   }\n\n   var mask = new Mask(new gamejs.graphics.Surface([overlapRect.width, overlapRect.height]));\n   var x,y;\n   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {\n      for (x=overlapRect.left; x<=overlapRect.right; x++) {\n         if (this.getAt(x - arect.left, y - arect.top) &&\n             otherMask.getAt(x - brect.left, y - brect.top)) {\n             mask.setAt(x, y);\n         }\n      }\n   }\n   return mask;\n};\n\n/**\n * Set bit at position.\n * @param {Number} x\n * @param {Number} y\n */\nMask.prototype.setAt = function(x, y) {\n   this._bits[x][y] = true;\n};\n\n/**\n * Get bit at position.\n *\n * @param {Number} x\n * @param {Number} y\n */\nMask.prototype.getAt = function(x, y) {\n   x = parseInt(x, 10);\n   y = parseInt(y, 10);\n   if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\n      return false;\n   }\n   return this._bits[x][y];\n};\n\n\n/**\n * Flip the bits in this map.\n */\nMask.prototype.invert = function() {\n   this._bits = this._bits.map(function(row) {\n      return row.map(function(b) {\n         return !b;\n      });\n   });\n};\n\n/**\n * @returns {Array} the dimensions of the map\n */\nMask.prototype.getSize = function() {\n   return [this.width, this.height];\n};\n\nobjects.accessors(Mask.prototype, {\n   /**\n    * Rect of this Mask.\n    */\n   'rect': {\n      get: function() {\n         return new gamejs.Rect([0, 0], [this.width, this.height]);\n      }\n   },\n   /**\n    * @returns {Number} number of set pixels in this mask.\n    */\n   'length': {\n      get: function() {\n         var c = 0;\n         this._bits.forEach(function(row) {\n            row.forEach(function(b) {\n               if (b) {\n                  c++;\n               }\n            });\n         });\n         return c;\n      }\n   }\n});\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/pixelcollision.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/thread.js":
/*!**************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/thread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar uri = __webpack_require__(/*! ./utils/uri */ \"./node_modules/gamejs/src/gamejs/utils/uri.js\");\nvar Callback = __webpack_require__(/*! ./utils/callback */ \"./node_modules/gamejs/src/gamejs/utils/callback.js\").Callback;\n\n/**\n * ignore\n */\nvar _EVENTS = exports._EVENTS = {\n   RESULT: 1001,\n   ALIVE: 1002,\n   LOG: 1004\n};\n\n/**\n * @fileoverview\n *\n * gamejs.worker makes it more convinient to work with W3C WebWorkers by providing a way to run\n * CommonJs modules inside of them. GameJs also provides the typically `gamejs.ready()` and\n * event loop to facilitate communication between workers and the main application.\n *\n * See the `examples/workers` directory for a running example.\n *\n * Create a worker with the main module \"foo-worker\" (see below for how the worker's module looks like):\n *\n *     var fooWorker = new Worker('./foo-worker');\n *     // Send a message to your worker.\n *     // The Message doesn't have to be a string but it\n *     // must be `JSON.stringify()`-able\n *     fooWorker.post(\"foobar\");\n *\n * You can also recieve messages from the worker:\n *\n *     // recieve events from the worker\n *     fooWorker.onEvent(function(event) {\n *         if(event.timestamp > ...)\n *      });\n *\n * And this is how the above referenced \"foo-worker\" module would looke like. As usual, we need a\n * `gamejs.ready()` to get started and within that we bind an event handler:\n *\n *     var gamejs = require('gamejs');\n *     gamejs.ready(function() {\n *         gamejs.event.onEvent(function(event) {\n *              var plaintext = fastCrack(event.password)\n *              ....\n *          });\n *     });\n *\n * Our event worker could do expensive calculations (seperate and not blocking the main game) when\n * recieving an event. Once the result is caculated, it can be sent back to the main application\n * with `gamejs.thread.post()`:\n *\n *     gamejs.thread.post({\n *        info: \"important message from worker\",\n *        timestamp: 12232435234\n *      });\n *\n * The main application would in turn recieve an event posted like this from `fooWorker.onEvent`, as seen above.\n *\n * This module is useful for expensive algorithms where the result does not have to available instantiously\n * (e.g., path-finding) or for continous logic which can be\n * calculated seperately from the rendering loop, and which only needs to feed back into the model of the rendering every\n * now and then (e.g. physics) The main draw back of the `Worker` model is that\n * you can only communicate with them via text messages (typically JSON.stringify()ed messages).\n */\n\n/**\n * true if this GameJs instance is being executed within a WebWorker\n * @type Boolean\n */\nvar inWorker = exports.inWorker = (this.importScripts !== undefined);\n\n/**\n * executed in scope of worker\n * @ignore\n */\nexports._ready = function() {\n   self.onmessage = function(event) {\n      gamejs.event._triggerCallbacks(event.data);\n   };\n   self.postMessage({\n     type: _EVENTS.ALIVE\n   });\n};\n\n/**\n * Send an event back to the main script.\n * @param {Object} data to be sent back to main script\n */\nexports.post = function(data) {\n  if (inWorker) {\n    self.postMessage({\n       type: _EVENTS.RESULT,\n       data: data\n    });\n  } else {\n    throw new Error('gamejs.postMessage only available in a thread/worker module');\n  }\n};\n\n/**\n * Send message to main context for logging\n * @ignore\n **/\nexports._logMessage = function() {\n   var args = [];\n   Array.prototype.forEach.call(arguments, function(a) {\n     args.push(a);\n   });\n   self.postMessage({\n      type: _EVENTS.LOG,\n      arguments: args\n   });\n};\n\n\n/**\n  * executed in scope of worker before user's main module\n  * @ignore\n  */\nvar workerPrefix = function workerPrefix() {\n   __scripts.forEach(function(script) {\n      try {\n         importScripts(script);\n      } catch (e) {\n         // can't help the worker\n      }\n   });\n};\n\n/**\n * Setup a worker which has `require()` defined\n * @ignore\n **/\nvar create = function(workerModuleId) {\n   var moduleRoot = uri.resolve(document.location.href, window.require.getModuleRoot());\n   var initialScripts = [];\n   Array.prototype.slice.apply(document.getElementsByTagName('script'), [0]).forEach(function(script) {\n      if (script.src) {\n         initialScripts.push(script.src);\n      }\n   });\n\n   var URL = window.URL || window.webkitURL;\n   var prefixString = workerPrefix.toString();\n   // don't be afraid...\n   prefixString = prefixString.substring(prefixString.indexOf(\"{\") + 1, prefixString.lastIndexOf(\"}\"));\n   var blob = new Blob([\n      'var __scripts = [\"' + initialScripts.join('\",\"') + '\"];',\n      prefixString,\n      ';self.require.setModuleRoot(\"' + moduleRoot + '\");',\n      'self.require.run(\"'+ workerModuleId +'\");'\n   ], {type: 'application\\/javascript'});\n\n   var blobURL = URL.createObjectURL(blob);\n   return new Worker(blobURL);\n};\n\n/**\n * The `Worker` constructor takes only one argument: a module id. This module\n * will be executed inside the newly created Worker. It is effectively the\n * main module of the Worker.\n *\n * Inside a Worker, you can use `require()` to import other scripts or\n * GameJs modules.\n *\n * **Note:** A Worker does not have access to the browser's `document`. So\n * a lot of GameJs modules - everything related to drawing to the canvas -\n * do not work in the Worker.\n *\n * You can use `gamejs.time.*`, `gamejs.utils.*`, `gamejs.event.*` and probably others\n * (as well as any module you write yourself for this purpose, of course).\n *\n * @param {String} moduleId The Worker's main module id. The main module will be executed in the worker\n */\nexports.Worker = function(moduleId) {\n   // FIXME id should be unchangeable\n   /**\n    * Unique id of this worker\n    * @property {Number}\n    */\n   var id = this.id = guid(moduleId);\n   var worker = create(moduleId);\n   var deadQueue = [];\n   var alive = false;\n   var self  = this;\n   var _CALLBACKS = [];\n   var _ERROR_CALLBACKS = [];\n\n   function triggerCallbacks(callbacks, event) {\n      callbacks.forEach(function(c) {\n         c.trigger(event);\n      });\n   }\n\n   worker.onmessage = function(event) {\n      if (event.data.type === _EVENTS.ALIVE) {\n         // if worker says he is alive -> send him the event queue so far\n         alive = true;\n         deadQueue.forEach(function(data) {\n            self.post(data);\n         });\n      } else if (event.data.type === _EVENTS.LOG) {\n         gamejs.logging.log.apply(null, [id].concat(event.data.arguments));\n      } else {\n         triggerCallbacks(_CALLBACKS, event.data.data);\n      }\n   };\n   worker.onerror = function(event) {\n      gamejs.logging.error('Error in worker \"' + id + '\" line ' + event.lineno + ': ', event.message);\n      triggerCallbacks(_ERROR_CALLBACKS, {\n         data: event.data,\n         worker: self,\n         event: event\n      });\n   };\n\n   this.onEvent = function(fn, scope) {\n      _CALLBACKS.push(new Callback(fn, scope));\n   };\n\n   this.onError = function(fn, scope) {\n      _ERROR_CALLBACKS.push(new Callback(fn, scope));\n   };\n\n   /**\n    * Send a message to the worker\n    *\n    * @param {Object} data Payload object which gets sent to the Worker\n    */\n   this.post = function(data) {\n      if (alive) {\n         worker.postMessage(data);\n      } else {\n         deadQueue.push(data);\n      }\n   };\n   return this;\n};\n\n/**\n * not a real GUID\n * @ignore\n */\nfunction guid(moduleId) {\n   var S4 = function() {\n      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n   };\n   return moduleId + '@' + (S4()+S4());\n}\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/thread.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/tiledmap.js":
/*!****************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/tiledmap.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var gamejs = __webpack_require__(/*! ../gamejs */ \"./node_modules/gamejs/src/gamejs.js\");\nvar objects = __webpack_require__(/*! ./utils/objects */ \"./node_modules/gamejs/src/gamejs/utils/objects.js\");\nvar xml = __webpack_require__(/*! ./utils/xml */ \"./node_modules/gamejs/src/gamejs/utils/xml.js\");\nvar base64 = __webpack_require__(/*! ./utils/base64 */ \"./node_modules/gamejs/src/gamejs/utils/base64.js\");\nvar uri = __webpack_require__(/*! ./utils/uri */ \"./node_modules/gamejs/src/gamejs/utils/uri.js\");\n\n/**\n * @fileoverview\n * This is a loader for the general purpose tile map editor \"Tiled\".\n *\n * This module can load all \".tmx\" files even if additionally base64 encoded\n * (can be configured in Tiled).\n *\n * This module loads the whole map definition, including the TileSets with\n * all necessary images. For an example on how to render a map loaded with\n * this module, see `examples/tiledmap`.\n *\n * You will typically create a Map instance with `Map(url)` and deal\n * with the layers, tilesets, etc. through the Map instance\n * instead of loading & creating them yourself.\n *\n * Only orthogonol maps are supported (no isometric maps).\n *\n * @see http://www.mapeditor.org/\n * @see https://github.com/bjorn/tiled/wiki/TMX-Map-Format\n */\n\n/**\n * My code is inspired by:\n *   * https://bitbucket.org/maikg/tiled2cocos/\n *   * https://github.com/obiot/melonJS/\n *\n */\n\n/**\n * A Tiled Map holds all layers defined in the tmx file as well\n * as the necessary tiles to render the map.\n * @param {String} url Relative or absolute URL to the tmx file\n */\nvar Map = exports.Map = function(url) {\n\n   url = uri.resolve(document.location.href, url);\n   var xmlDoc = xml.Document.fromURL(url);\n   var mapNode = xmlDoc.element('map');\n\n   /**\n    * Width of a single tile in pixels\n    * @type Number\n    */\n   this.tileWidth = mapNode.attribute('tilewidth');\n   /**\n    * Height of a single tile in pixels\n    * @type Number\n    */\n   this.tileHeight = mapNode.attribute('tileheight');\n   /**\n    * Width of the map in tiles\n    * @type Number\n    */\n   this.width = mapNode.attribute('width');\n   /**\n    * Height of the map in tiles\n    * @type Number\n    */\n   this.height = mapNode.attribute('height');\n\n   var orientation = mapNode.attribute('orientation');\n   if (orientation !== 'orthogonal') {\n      throw new Error('only orthogonol maps supported');\n   }\n\n   /**\n    * Custom properties of the map\n    */\n   this.properties = {};\n   setProperties(this.properties, mapNode);\n\n   /**\n    * All tiles of this map.\n    * @type {TileSet}\n    */\n   this.tiles = new TileSets(mapNode, url);\n   this.layers = loadLayers(mapNode);\n   return this;\n};\n\n/**\n * A Tile. Can not be instantiated. Get a Tile by calling `getTile(gid)`\n * on a `TileSets` instance.\n */\nvar Tile = exports.Tile = function() {\n   /**\n    * @type {gamejs.graphics.Surface}\n    */\n   this.surface = null;\n   /**\n    * @type {Object}\n    */\n   this.properties = null;\n   throw new Error('Can not be instantiated.');\n};\n\n/**\n * A TileSets instance holds all tilesets of a map. This class\n * makes it easy to get the image for a certain tile ID. You usually\n * don't care about in which specific TileSet an image is so this\n * class holds them all and deals with the lookup.\n *\n * You don't usually create a `TileSets` instance yourself, instead\n * it is automatically created and attached to a `Map`.\n */\nvar TileSets = exports.TileSets = function(mapNode, mapUrl) {\n   var tileSets = [];\n\n   /**\n    * Retrieve the image for a tile ID (gid).\n    *\n    * @param {Number} gid global tile id to retrieve\n    * @returns {gamejs.graphics.Surface} the Surface for the gid\n    */\n   this.getSurface = function(gid) {\n      var tile = this.getTile(gid);\n      return tile && tile.surface || null;\n   };\n\n   /**\n    * @param {Number} gid global tile id\n    * @returns {Object} the custom properties of this tile\n    */\n   this.getProperties = function(gid) {\n      var tile = this.getTile(gid);\n      return tile && tile.properties || {};\n   };\n\n   /**\n    * @param {Number} gid global tile id\n    * @returns {Object} the Tile object for this gid\n    */\n   this.getTile = function(gid) {\n      var tile = null;\n      tileSets.some(function(tileSet, idx) {\n         if (tileSet.firstGid <= gid) {\n            tile = tileSet.tiles[gid - tileSet.firstGid];\n            return true;\n         }\n         return false;\n      }, this);\n      return tile;\n   };\n\n   var loadTileSet = function(tileSetNode) {\n      var tiles = [];\n      var tileWidth = tileSetNode.attribute('tilewidth');\n      var tileHeight = tileSetNode.attribute('tileheight');\n      var spacing = tileSetNode.attribute('spacing') || 0;\n      // broken in tiled?\n      var margin = 0;\n\n      var imageNode = tileSetNode.element('image');\n      var imageAtlasFile = imageNode.attribute('source');\n      var imageUrl = uri.makeRelative(uri.resolve(mapUrl, imageAtlasFile));\n      var atlas = gamejs.image.load(imageUrl);\n      // FIXME set transparency if imageNode.attribute('trans') is set\n\n      var tileNodes = tileSetNode.elements('tile');\n      var dims = atlas.getSize();\n      var imgSize = new gamejs.Rect([0,0], [tileWidth, tileHeight]);\n      var idx = 0;\n      var y = 0;\n      while (y + tileHeight <= dims[1]) {\n         var x = 0;\n         while (x + tileWidth <= dims[0]) {\n            var tileImage = new gamejs.graphics.Surface(tileWidth, tileHeight);\n            var rect = new gamejs.Rect([x, y], [tileWidth, tileHeight]);\n            tileImage.blit(atlas, imgSize, rect);\n            var tileProperties = {};\n            /* jshint ignore:start */\n            // function within loop\n            tileNodes.some(function(tileNode) {\n               if (tileNode.attribute('id') === idx) {\n                  setProperties(tileProperties, tileNode);\n                  return true;\n               }\n            }, this);\n            /* jshint ignore:end */\n            tiles.push({\n               surface: tileImage,\n               properties: tileProperties\n            });\n            x += tileWidth + spacing;\n            idx++;\n         }\n         y += tileHeight + spacing;\n      }\n      return tiles;\n   };\n\n   /**\n    *\n    * constructor\n    **/\n   mapNode.elements('tileset').forEach(function(tileSetNode) {\n      var firstGid = tileSetNode.attribute('firstgid');\n      var externalSource = tileSetNode.attribute('source');\n      if (externalSource) {\n         var tileSetDocument = xml.Document.fromURL(uri.resolve(mapUrl, externalSource));\n         tileSetNode = tileSetDocument.element('tileset');\n      }\n      tileSets.push({\n         tiles: loadTileSet(tileSetNode),\n         firstGid: firstGid\n      });\n   });\n   tileSets.reverse();\n\n   return this;\n};\n\n/**\n * loadLayers\n */\nvar H_FLIP = 0x80000000;\nvar V_FLIP = 0x40000000;\nvar loadLayers = function(mapNode) {\n   var layers = [];\n\n   var getGids = function(layerNode) {\n      var dataNode = layerNode.element('data');\n      var encoding = dataNode.attribute('encoding');\n      var compression = dataNode.attribute('compression');\n      var data = \"\";\n      dataNode.children().forEach(function(textNode) {\n         data += textNode.value();\n      });\n      var byteData = [];\n      if (encoding === 'base64') {\n         if (compression) {\n            throw new Error('Compression of map data unsupported');\n         }\n         byteData = base64.decodeAsArray(data, 4);\n      } else if (encoding === 'csv') {\n         data.trim().split('\\n').forEach(function(row) {\n            row.split(',', width).forEach(function(entry) {\n               byteData.push(parseInt(entry, 10));\n            });\n         });\n      } else {\n         // FIXME individual XML tile elements\n         throw new Error('individual tile format not supported');\n      }\n      return byteData;\n   };\n\n   var width = mapNode.attribute('width');\n   var height = mapNode.attribute('height');\n   mapNode.elements('layer').forEach(function(layerNode) {\n      // create empty gid matrix\n      var gidMatrix = [];\n      var i = height;\n      while (i-->0) {\n         var j = width;\n         gidMatrix[i] = [];\n         while (j-->0) {\n            gidMatrix[i][j] = 0;\n         }\n      }\n\n      getGids(layerNode).forEach(function(gid, idx) {\n         // FIXME flipX/Y currently ignored\n         var flipX = gid & H_FLIP;\n         var flipY = gid & V_FLIP;\n         // clear flags\n         gid &= ~(H_FLIP | V_FLIP);\n         gidMatrix[parseInt(idx / width, 10)][parseInt(idx % width, 10)] = gid;\n      });\n      layers.push({\n         gids: gidMatrix,\n         opacity: layerNode.attribute('opacity'),\n         visible: layerNode.attribute('visible'),\n         properties: setProperties({}, layerNode)\n      });\n   });\n   return layers;\n};\n\n/**\n * set generic <properties><property name=\"\" value=\"\">... on given object\n */\nvar setProperties = function(object, node) {\n   var props = node.element('properties');\n   if (!props) {\n      return;\n   }\n   props.elements('property').forEach(function(propertyNode) {\n      var name = propertyNode.attribute('name');\n      var value = propertyNode.attribute('value');\n      object[name] = value;\n   });\n   return object;\n};\n\n\n/**\n * FIXME explain viewRect (change it to sroll!) and image, mapImage and how to update, redraw\n */\nvar MapView = exports.MapView = function(map) {\n\n    this.timeout = 0;\n\n    this.layerViews = map.layers.map(function(layer) {\n      return new LayerView(layer, {\n         tileWidth: map.tileWidth,\n         tileHeight: map.tileHeight,\n         width: map.width,\n         height: map.height,\n         tiles: map.tiles\n      });\n    });\n    this.viewRect = new gamejs.Rect([0,0], [map.width * map.tileWidth, map.height*map.tileWidth]);\n    this.image = new gamejs.graphics.Surface([this.viewRect.width, this.viewRect.height]);\n    this.mapImage = this.image.clone();\n    this.redraw();\n    return this;\n};\n\nMapView.prototype.redraw = function() {\n    this.layerViews.forEach(function(layer) {\n        layer.draw(this.mapImage);\n    }, this);\n};\n\nMapView.prototype.draw = function(display, offset) {\n  display.blit(this.mapImage, offset || [0,0], this.viewRect);\n};\n\n\n\n/**\n * LayerView\n * Renders the layer to a big surface.\n */\nvar LayerView = exports.LayerView = function(layer, opts) {\n\n   this.draw = function(display) {\n      display.blit(this.surface);\n   };\n   /**\n    * constructor\n    */\n   this.surface = new gamejs.graphics.Surface(opts.width * opts.tileWidth, opts.height * opts.tileHeight);\n   this.surface.setAlpha(layer.opacity);\n\n   /**\n    * Note how below we look up the \"gid\" of the tile images in the TileSet from the Map\n    * ('opt.tiles') to get the actual Surfaces.\n    */\n   layer.gids.forEach(function(row, i) {\n      row.forEach(function(gid, j) {\n         if (gid ===0) {\n            return;\n         }\n\n         var tileSurface = opts.tiles.getSurface(gid);\n         if (tileSurface) {\n            this.surface.blit(tileSurface,\n               new gamejs.Rect([j * opts.tileWidth, i * opts.tileHeight], [opts.tileWidth, opts.tileHeight])\n            );\n         } else {\n            gamejs.log('no gid ', gid, i, j, 'layer', i);\n         }\n      }, this);\n   }, this);\n   return this;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/tiledmap.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/time.js":
/*!************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/time.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileoverview\n * Only used by GameJs internally to provide a game loop.\n * @ignore\n */\n\nvar Callback = __webpack_require__(/*! ./utils/callback */ \"./node_modules/gamejs/src/gamejs/utils/callback.js\").Callback;\n\nvar TIMER_LASTCALL = null;\nvar STARTTIME = null;\n\n/** @ignore **/\nvar _CALLBACKS = exports._CALLBACKS = [];\n// `window` is not accessible in webworker (would lead to TypeError)\n// @@ this cross-browser fuckery has to go away ASAP.\nvar reqAnimationFrame = typeof(window) != 'undefined' ?\n                        window.requestAnimationFrame ||\n                        window.webkitRequestAnimationFrame ||\n                        window.mozRequestAnimationFrame ||\n                        window.oRequestAnimationFrame ||\n                        window.msRequestAnimationFrame ||\n                        null : null;\n\nvar reqAniFrameRecursive = function() {\n   perInterval();\n   reqAnimationFrame(reqAniFrameRecursive);\n};\n\nvar triggerCallbacks = function(msDuration) {\n   _CALLBACKS.forEach(function(c) {\n      c.trigger(msDuration);\n   });\n};\n\n/**\n * @ignore\n */\nexports.init = function() {\n   STARTTIME = Date.now();\n\n   if (reqAnimationFrame) {\n      reqAnimationFrame(reqAniFrameRecursive);\n   } else {\n      setInterval(perInterval, 10);\n   }\n   return;\n};\n\nvar perInterval = function() {\n   var msNow = Date.now();\n   triggerCallbacks(msNow - (TIMER_LASTCALL || msNow));\n   TIMER_LASTCALL = msNow;\n   return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/time.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/arrays.js":
/*!********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/arrays.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Utility functions for working with Obiects\n * @param {Object} item\n * @param {Array} array\n * @param {Object} returns removed item or null\n */\n\nexports.remove = function(item, array) {\n   var index = array.indexOf(item);\n   if (index !== -1) {\n      return array.splice(array.indexOf(item), 1);\n   }\n   return null;\n};\n\n/**\n * Shuffles the array *in place*.\n * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n */\nexports.shuffle = function(array) {\n    var len = array.length -1;\n    for (var i = len; i > 0; i--) {\n        var idx = parseInt(Math.random() * (i + 1), 10);\n        var item = array[i];\n        array[i] = array[idx];\n        array[idx] = item;\n    }\n    return array;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/arrays.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/base64.js":
/*!********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/base64.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview\n * Base64 encode / decode\n * @author http://www.webtoolkit.info\n */\n\n\nvar keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n/**\n * Decodes a base64 encoded string to a string.\n */\nvar decode = exports.decode = function(input) {\n   var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;\n   input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n   while (i < input.length) {\n      enc1 = keyStr.indexOf(input.charAt(i++));\n      enc2 = keyStr.indexOf(input.charAt(i++));\n      enc3 = keyStr.indexOf(input.charAt(i++));\n      enc4 = keyStr.indexOf(input.charAt(i++));\n\n      chr1 = (enc1 << 2) | (enc2 >> 4);\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n      chr3 = ((enc3 & 3) << 6) | enc4;\n\n      output.push(String.fromCharCode(chr1));\n\n      if (enc3 != 64) {\n         output.push(String.fromCharCode(chr2));\n      }\n      if (enc4 != 64) {\n         output.push(String.fromCharCode(chr3));\n      }\n   }\n\n   output = output.join('');\n   return output;\n};\n\n/**\n * Decodes a base64 encoded string into a byte array\n * @param {String} input\n * @param {Array} bytes bytes per character, defaults to 1\n */\nexports.decodeAsArray = function(input, bytes) {\n   bytes = bytes || 1;\n   var decoded = decode(input);\n   var len = decoded.length / bytes;\n   var array = [];\n   var i,j;\n   for (i=0; i< len; i++) {\n      array[i] = 0;\n      for (j = bytes - 1; j >=0; --j) {\n         array[i] += decoded.charCodeAt((i * bytes) + j) << (j <<3 );\n      }\n   }\n   return array;\n}\n;\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/base64.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/callback.js":
/*!**********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/callback.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview\n * Manage a callback with invocation scope. This is used internally by GameJs but might be useful for others.\n */\n\n/**\n * @param {Function} callback\n * @param {Object} scope with which the callback will be triggered\n */\nvar Callback = exports.Callback = function(fn, scope) {\n\tthis.fn = fn;\n\tthis.fnScope = scope || {};\n\treturn this;\n};\n/**\n * Any arguments passed to `trigger` will be passed to the callback.\n */\nCallback.prototype.trigger = function() {\n\tthis.fn.apply(this.fnScope, arguments);\n};\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/callback.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/objects.js":
/*!*********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/objects.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Utility functions for working with Objects\n */\n\n/**\n * Put a prototype into the prototype chain of another prototype.\n * @param {Object} subClass\n * @param {Object} superClass\n */\nexports.extend = function(subClass, superClass) {\n   if (subClass === undefined) {\n      throw new Error('unknown subClass');\n   }\n   if (superClass === undefined) {\n      throw new Error('unknown superClass');\n   }\n   var F;\n   /* jshint ignore:start */\n   F = new Function();\n   /* jshint ignore:start */\n   F.prototype = superClass.prototype;\n   /* jshint ignore:end */\n   subClass.prototype = new F();\n   subClass.prototype.constructor = subClass;\n   subClass.superClass = superClass.prototype;\n   subClass.superConstructor = superClass;\n   return;\n};\n\n/**\n * Creates a new object as the as the keywise union of the provided objects.\n * Whenever a key exists in a later object that already existed in an earlier\n * object, the according value of the earlier object takes precedence.\n * @param {Object} obj... The objects to merge\n */\nexports.merge = function() {\n   var result = {};\n   var i, property;\n      for (i = arguments.length; i > 0; --i) {\n         var obj = arguments[i - 1];\n         for (property in obj) {\n            result[property] = obj[property];\n         }\n      }\n   return result;\n};\n\n/**\n * fallback for Object.keys\n * @param {Object} obj\n * @returns {Array} list of own properties\n * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\n */\nvar keys = exports.keys = function(obj) {\n   if (Object.keys) {\n      return Object.keys(obj);\n   }\n\n   var ret=[],p;\n   for (p in obj) {\n      if(Object.prototype.hasOwnProperty.call(obj, p)) {\n         ret.push(p);\n      }\n   }\n   return ret;\n};\n\n/**\n * Create object accessors\n * @param {Object} object The object on which to define the property\n * @param {String} name name of the property\n * @param {Function} get\n * @param {Function} set\n * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty\n */\nvar accessor = exports.accessor = function(object, name, get, set) {\n   // ECMA5\n   if (Object.defineProperty !== undefined) {\n      Object.defineProperty(object, name, {\n         get: get,\n         set: set\n      });\n   // non-standard\n   } else if (Object.prototype.__defineGetter__ !== undefined) {\n      object.__defineGetter__(name, get);\n      if (set) {\n         object.__defineSetter__(name, set);\n      }\n   }\n\treturn;\n};\n\n/**\n * @param {Object} object The object on which to define or modify properties.\n * @param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.\n * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties\n */\nexports.accessors = function(object, props) {\n   keys(props).forEach(function(propKey) {\n      accessor(object, propKey, props[propKey].get, props[propKey].set);\n   });\n   return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/objects.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/strings.js":
/*!*********************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/strings.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Working with strings\n */\n\n/**\n * Get the longest common segment that two strings\n * have in common, starting at the beginning of the string\n * @param {String} str1 a string\n * @param {String} str2 another string\n * @returns {String} the longest common segment\n */\nexports.getCommonPrefix = function getCommonPrefix(str1, str2) {\n    if (str1 === null || str2 === null) {\n        return null;\n    } else if (str1.length > str2.length && str1.indexOf(str2) === 0) {\n        return str2;\n    } else if (str2.length > str1.length && str2.indexOf(str1) === 0) {\n        return str1;\n    }\n    var length = Math.min(str1.length, str2.length);\n    var i;\n    for (i = 0; i < length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, length);\n};\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/strings.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/uri.js":
/*!*****************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/uri.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview Utilies for URI handling.\n *\n */\n\nvar URI_REGEX = new RegExp(\n    '^' +\n    '(?:' +\n      '([^:/?#.]+)' +                     // scheme - ignore special characters\n                                          // used by other URL parts such as :,\n                                          // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n      '(?:([^/?#]*)@)?' +                 // userInfo\n      '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + // domain - restrict to letters,\n                                          // digits, dashes, dots, percent\n                                          // escapes, and unicode characters.\n      '(?::([0-9]+))?' +                  // port\n    ')?' +\n    '([^?#]+)?' +                         // path\n    '(?:\\\\?([^#]*))?' +                   // query\n    '(?:#(.*))?' +                        // fragment\n    '$');\n\n/**\n * Resolve path against URI.\n *\n * @param {String} uri\n * @param {String} path to resolve\n */\nvar resolve = exports.resolve = function(uri, path) {\n   var m = match(uri);\n   var n = match(path);\n   var host = m[1] + '://' + m[3];\n   if (n[1]) {\n      return path;\n   }\n   if (m[4]) {\n      host = host + \":\" + m[4];\n   }\n   var absolutePath = m[5];\n   if (path.charAt(0) !== '/') {\n      var lastSlashIndex = absolutePath.lastIndexOf('/');\n      absolutePath = absolutePath.substr(0, lastSlashIndex + 1) + path;\n   } else {\n      absolutePath = path;\n   }\n   return host + removeDotSegments(absolutePath);\n\n};\n\n/**\n * Try to match an URI against a regex returning the following\n * capture groups:\n *     $1 = http              scheme\n *     $2 = <undefined>       userInfo -\\\n *     $3 = www.ics.uci.edu   domain     | authority\n *     $4 = <undefined>       port     -/\n *     $5 = /pub/ietf/uri/    path\n *     $6 = <undefined>       query without ?\n *     $7 = Related           fragment without #\n *\n * @param {String} uri\n */\nvar match = exports.match = function(uri) {\n   return uri.match(URI_REGEX);\n};\n\n/**\n * Make an absolute URI relative to document.location.href\n * @param {String} uri\n * @returns The relative URI or the unchanged URI if it's not\n * possible to make it relative to the path of document.location.href.\n */\nvar makeRelative = exports.makeRelative = function(uri) {\n   var docLocPath = resolve(document.location.href, './');\n   if (uri.indexOf(docLocPath) === 0) {\n      uri = './' + uri.substring(docLocPath.length);\n   }\n   return uri;\n};\n\n/**\n * Removes dot segments in given path component\n */\nvar removeDotSegments = function(path) {\n   if (path == '..' || path == '.') {\n      return '';\n   }\n   var leadingSlash = path.indexOf('/') > -1;\n\n   var segments = path.split('/');\n   var out = [];\n\n   var pos;\n   for (pos = 0; pos < segments.length; ) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n         if (leadingSlash && pos == segments.length) {\n            out.push('');\n         }\n      } else if (segment == '..') {\n         if (out.length > 1 || out.length !== 1 && out[0] !== '') {\n            out.pop();\n         }\n         if (leadingSlash && pos == segments.length) {\n            out.push('');\n         }\n      } else {\n         out.push(segment);\n         leadingSlash = true;\n      }\n   }\n   return out.join('/');\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/uri.js?");

/***/ }),

/***/ "./node_modules/gamejs/src/gamejs/utils/xml.js":
/*!*****************************************************!*\
  !*** ./node_modules/gamejs/src/gamejs/utils/xml.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview\n *\n * Provides facilities for parsing a xml String.\n *\n * You will typically get a `gamejs.xml.Document` instance\n * by loading the data with one of the two static\n * `Document.fromString(string)` or `Document.fromUrl(url)`.\n\n * Querying for `elements(name)` or `children()` will return a\n * new `gamejs.xml.Document` matching your result (or null).\n *\n * Use `attributes(name)` and `value()` to get the data stored\n * in the XML Document.\n */\n\n/**\n * XMLParser\n */\nvar Parser = exports.Parser = function() {\n\n   var xmlDoc = null;\n   var parser = new DOMParser();\n\n   this.parseFromString = function(xmlString) {\n      xmlDoc = parser.parseFromString(xmlString, 'text/xml');\n      return xmlDoc;\n   };\n\n   return this;\n};\n\n/**\n * Instantiate with the static functions `Document.fromString()` and `fromURL()`.\n */\nvar Document = exports.Document = function(xmlDocument) {\n   if (!xmlDocument || (!xmlDocument instanceof XMLDocument) ) {\n      throw new Error('Need a valid xmlDocument.');\n   }\n   /** @ignore **/\n   this._xmlDocument = xmlDocument;\n   return this;\n};\n\n/**\n * Returns the first element in the current document whose tag-name matches\n * the given 'name'.\n * @returns gamejs.xml.Document\n */\nDocument.prototype.element = function(name) {\n   var elem = this._xmlDocument.getElementsByTagName(name)[0];\n   return elem && new Document(elem) || null;\n};\n\n/**\n * Returns all elements in the current document whose tag-name matches\n * the given 'name'.\n * @returns an Array of gamejs.xml.Document\n */\nDocument.prototype.elements = function(name) {\n   var elems = this._xmlDocument.getElementsByTagName(name);\n   return Array.prototype.slice.apply(elems, [0]).map(function(elem) {\n      return new Document(elem);\n   });\n};\n\n/**\n * Returns the attribute value of this document.\n *\n * @returns String\n */\nDocument.prototype.attribute = function(name) {\n   var attributeValue = this._xmlDocument.getAttribute(name);\n   attributeValue = attributeValue ? attributeValue.trim() : null;\n   if (attributeValue === null) {\n      return null;\n   }\n   if (attributeValue.toLowerCase() === 'true') {\n      return true;\n   }\n   if (attributeValue.toLowerCase() === 'false') {\n      return false;\n   }\n   var attributeIntValue = parseInt(attributeValue, 10);\n   var attributeFloatValue = parseFloat(attributeValue, 10);\n   if (!isNaN(attributeIntValue)) {\n      if (attributeFloatValue !== attributeIntValue) {\n         return attributeFloatValue;\n      }\n      return attributeIntValue;\n   }\n   return attributeValue;\n};\n\n/**\n * Returns the nodevalue of the current xml document\n * @returns String\n */\nDocument.prototype.value = function() {\n   return this._xmlDocument.nodeValue;\n};\n\n/**\n * Returns all children of this xml document\n * @returns Array of gamejs.xml.Document\n */\nDocument.prototype.children = function() {\n   return Array.prototype.slice.apply(this._xmlDocument.childNodes, [0]).map(function(cNode) {\n      return new Document(cNode);\n   });\n};\n\n/**\n * @returns gamejs.xml.Document\n */\nDocument.fromString = function(xmlString) {\n   var parser = new DOMParser();\n   var xmlDoc = parser.parseFromString(xmlString, 'text/xml');\n   return new Document(xmlDoc);\n};\n\n/**\n * @returns gamejs.xml.Document\n */\nDocument.fromURL = function(url) {\n   var response = new XMLHttpRequest();\n   response.open('GET', url, false);\n   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n   response.setRequestHeader('Content-Type', 'text/xml');\n   response.overrideMimeType('text/xml');\n   response.send();\n   return new Document(response.responseXML);\n};\n\n\n//# sourceURL=webpack:///./node_modules/gamejs/src/gamejs/utils/xml.js?");

/***/ })

/******/ });